享学课堂

学而不思则罔，思而不学则殆。
精气神，精满气足神旺。
学习效率，有效的时间内学习并掌握更多的知识。
天才不可怕，可怕的是天才比你更努力。
无论以前还是现在享过的福，偷过的懒，早晚都会让你连本带利的还回来。

名词解释：
01.可见性：多个线程访问同一个变量时，一个线程修改了变量值，其他线程能立即看到修改后的值。
02.有序性：程序执行的顺序按代码顺序执行。
03.原子性：一个操作是不可中断的，要么直接执行完毕，要么就不执行。
04.a++：会生成多个指令，多线程执行时，在不保证原子性的情况下，执行的数据不准确。

05.基本类型变量：利用八个关键字声明的变量，不能是他们的包装类。
06.引用类型变量：除八个关键字外，其他所有变量均是引用类型变量。
07.字面量：给基本类型以及String赋值的方式就叫做字面量。
int a = 10;
String a = "abc";
08.实参：实际传入的参数（调用方法传入的参数）
09.形参：接收传入的参数（方法的参数）
10.常量：不可变的数据
直接常量：具体的数值（八种基本数据类型）
符号常量：符号化的常量，就是给直接常量起个名。

11.一个变量的结构构成：
在程序运行过程中存储可以变化的数据。
变量的本身只是内存单元，内存单元可以存储数据，也可以将存储的数据读出来。
int x 的含义是：告诉编译期，申请4个字节的内存空间，以后这块单元（4byte字节）就叫做 x 了；
基本数据类型的变量的数值，直接就是这块单元的数值，可以直接在栈上分配。
引用类型的变量，这块单元存的是对象在堆上的地址。启动栈上分配后，在没出方法作用域且较小的情况下，分配在栈上，其他时候分配在堆上。
String text=new String(“abc”);
1）String 是类型，其class信息在方法区（永久代/元空间）。
2）text   是引用变量。存储的是对象的地址。作为成员变量时，跟随所在类的对象在堆上；
作为局部变量时，在栈上栈帧的局部变量表中，存储的是对象在堆内存中的地址。
3）new String("abc") 是对象，在堆内存上，但“abc”在字符串常量池里。
4）启用栈上分配后，在没有逃出方法体的情况下，对象也会分配在栈上。
5）字符串常量如果在编译期就可以确定，那就在常量池里；在运行期才能确定，那就在堆里。1.7之后，字符串常量池物理上在堆里，逻辑上仍然属于方法区。

目录
第一章 泛型 Generic
第二章 注解，反射、动态代理
第三章 多线程，锁以及锁原理，线程池
第四章 序列化
第五章 IO流 与 AES加密加固
第六章 JVM虚拟机的原理
第七章 热修复 ClassLoader 机制
第八章 Kotlin
第九章 自定义UI
第十章 Android 日常总结
第十一章 混淆 ProGuard，参见app下的proguard文件，App研发录
第十二章 MVVM、MVC、MVP
第十三章 网络请求
第十四章 IPC机制，AIDL
第十五章 NDK 编程
第十六章 AsyncTask 已废弃

第一章 泛型 Generic
01.什么是泛型，有哪些？
在定义类、接口和方法时，使类型成为参数，分别被称为泛型类、泛型接口、泛型方法。
除泛型参数外，泛型类和普通类没区别。
通常使用 T、E、K、V，可以多个参数，也可以全拼。
泛型类/接口：
public class/interface A<T>{
}
泛型方法：
public <T,V extends Comparable> void a(T a){
}

02.泛型的好处，或者说为什么需要泛型？
1）泛型是一种参数化类型的机制，适用于多种数据类型执行相同的代码。例如集合框架。
2）泛型是一种编译时类型确认机制。在编译期，可以进行更强的代码类型检查，确保泛型集合都是同类型的对象。所以泛型中的实例（对象）在使用时指定，不需要强制类型转换，避免在运行时出现 ClassCastException。

03.限定类型变量，在声明泛型类、方法、接口时使用
1）T extends X：T代表子类型，X表示超类上限；
2）限定类型书写规则为：T,V extends 类 & 接口 & 接口。
有类则类必须在最前，且只能有一个，接口可以多个。逗号分隔后是不继承的。
例：T,V extends Serializable & Comparable： T与后边的类和接口没有继承关系

04.泛型中的约束和局限性：七种
1）无法实例化具有基本类型的泛型类型。因为基本类型不是对象。
2）无法实例化泛型泛型的参数类型 T。也就是不能new T()。
3）泛型类实例化对象时，前后的泛型类型必须统一，即使是继承关系也不行。
4）无法用 instanceof 做比，因为对象通过getclass()方法获取的类名是不带后边类型参数的。java中的泛型是伪泛型，包装时后边的类型会被擦除，强制转成 原生类型（Object）或者限定类型变量的第一个类。
5）无法在静态域或方法中使用。因为泛型是对象创建时才初始化，而静态域与方法是在new之前就创建好的。
但是本身就是泛型方法就可以，如：
private static <T> T getInstance(){};
因为调用的同时类型就确定了，所以可以使用。
6）无法创建参数化类型的数组
不带虽然可以，但不推荐，还是用 List 更好。
ApiResponse<String>[] response = new ApiResponse<String>[2]; //不可以
ApiResponse<String>[] response = new ApiResponse[2];//可以，但不推荐
7）无法创建，捕获或抛出参数化类型的对象。
泛型类不能继承 Exception/Throwable。这么写是不行的：class A<T> extends Exception{}
可以作为限定类型变量，例：T extends Exception，但是不能捕获（catch）到继承Exception/Throwable的泛型类实例（对象），但可以抛出，也就是throws T

05.通配符类型，定义方法、成员变量时使用，不能在类、接口中使用。
1）无限通配符：?，表示对类型没有限制，当成object理解就行了，调用getFist返回的是object类型，setFist不能被调用。
2）? extends X：限定了参数的父类上限，kotlin 是 out，主要用于数据的安全访问，可以访问X及其子类型，并且不能写入非空数据
可以理解为生产者，只卖不收。
分两种情况：
1、作为参数传递时，传入的参数只能是X以及X的子类，如下
public void print(GenericType<? extends X> type){}//传入的参数只能是X以及他的子类

2、作为成员变量或者局部变量时，只能get，不能set，也不能add，如下：
GenericType<? extends X> type=new GenericType<>();
type.setData(new Child());//不能这样设置，传入的子类具体是哪个是不确定的。
X x=type.getData();//可以获取，返回X

List<? extends X> list=new List<>();
list.add(child)//这样也是不行的。

3）？super X：限定参数的子类下限，kotlin 是 in，主要用于数据的安全写入，可以写入X及其子类。
可以理解为消费者，只买不卖。
也分两种情况：
1、作为参数传递时，传入的参数只能是X以及X的超类，如下：
public void print(GenericType<? supper X> type)//传入的参数只能是X以及他的超类

2、作为成员变量或者局部变量时，set的只能是X或X的子类，get时获取的是object对象。
GenericType<? super X> type=new GenericType<>();
type.setData(new X());//只能是X或X的子类
type.setData(new child());//只能是他本身或其子类，
Object data=type.getData();//可以获取，但获取的是object对象

加深理解：super 为什么不能添加X的父类，只能添加自身与子类？
1.与X的父类同级别的其他类与X本身可能冲突。
2.X及其子类可能存在父类没有的方法，父类不能安全转型成X。
同时因为向上转型的问题，取出来的对象是Object类型的。

06.虚拟机是如何实现泛型的？
1）在C#中，List<Integer> 与List<String>是两个不同的类型，在系统运行初期生成，有自己的方法和数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真泛型。
2）java语言中的泛型不一样，他只在程序源码中存在，在编译后的字节码中，T就已经替换为原来的原生类型object（Raw Type，也称为裸类型），并且在合适的地方插入了强转代码，因此List<Integer> 与List<String>的原生类型是List<Object>，就是同一个类，
所以泛型技术实际上是java语言的一颗语法糖，JAVA语言中的泛型实现方法为类型擦除，基于这种方法实现的泛型称为伪泛型。
所以将一段java代码编译成class文件后，再用字节码反编译工具进行反编译后，泛型就都不见了，程序又变回了java泛型出现前的写法，泛型都变回了原生类型。 如果是限定列表，那就默认取第一个类（接口）作为原生类型。
由于类型的擦除导致泛型类是一样的，所以JCP组织对虚拟机规范做出了相应的修改，引入了注入Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题。
Signature是其中最重要的一项属性，他的作用就是存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息，修改后的虚拟机规范要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确的识别Signature参数。
另外，从Signature属性我们还可以得出结论，擦除仅仅只是对code属性中的字节码进行擦除，但是元数据还是保存了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。


第二章 注解，反射、动态代理
第一节 注解
01.注解 Annotation，JDK5.0引入的一种注释机制。
关键字 @interface ，来定义一个注解类。

02.元注解：声明注解类的应用范围
1）@Target：表示注解类可以使用的范围
01、ElementType.PACKAGE：用于包声明
02、ElementType.TYPE：用于类
03、ElementType.FIELD：用于字段或属性
04、ElementType.CONSTRUCTOR：用于构造函数
05、ElementType.METHON：用于方法
06、ElementType.LOCAL_VARIABLE：用于局部变量
07、ElementType.PARAMETER：用于方法参数
08、ElementType.ANNOTATION_TYPE：可以用于注解类型
09、ElementType.TYPE_USE：用于类的任何元素
10、ElementType.TYPE_PARAMETER：用于类型参数声明
2）@Retention：规定注解类存在的范围，三种：
01、RetentionPolicy.SOURCE：只在源码中存在，Javac编译成class文件时会被剔除掉，其中会执行APT操作。可以用于生成额外的类或者语法检查（如参数类型限定）。
02、RetentionPolicy.CLASS：可以在javac编译后的class文件中存在，代码运行时会被忽略。可以进行插桩操作，对于相同的代码，可以通过注解来同时添加，如埋点操作。
03、RetentionPolicy.RUNTIME：可以在代码运行时存在，反射就应用在此，也只能用在此处。
3）@Documented：被javadoc工具提取成文档
4）@Inherited：表示允许子类继承父类中定义的注解
5）参数类型限定的注解类有：@IntDef,@DrawableRes，在androidx.annotation

03.注解类中可以有多个属性，可以有默认值；在只有一个的时候使用value字段，此为默认字段。传值时，只有一个字段value时，可以直接赋值，多个值时需要key-value对应。
04.Java中Enum（枚举）实际是特殊单例的静态成员变量，在运行期所有枚举类作为单例，加载到内存中，比常量多5到10倍的内存占用。
05.APT 注解处理器：Annotation Processor Tools，javac自带。EventBus3，tinker，butterknifer中都有应用。
06.编译期可以进行字节码插桩，可以使用 ASM，工作时期是在class文件打包成dex时。

第二节 反射原理
01.反射 Reflection 原理
反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。
反射是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection Api取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。
反射机制主要提供了一下功能：
1）在运行时构造任意一个类的对象。
2）在运行时获取任意一个类的方法和成员变量。
3）在运行时调用任意一个对象的方法或属性。

02.Class类
用来描述类的，也就是对类的封装。一个类可以有多个实例对象，但只会有一个class对象，其中包含了封装类的类名，属性，方法，构造器，接口信息等。
获取class实例的五种方式：
1）通过类名获取：类名.class
2）通过对象获取：对象.getclass()
3）通过全类名获取：Class.forName(全类名)
4）classloader.loadClass(全类名)
5）八种基本类型还能获取type，如：Integer.TYPE

03.class常用方法：
1）static Class forName(String name) 返回指定类名name的class对象
2）Object newInstance() 调用缺省构造函数，返回该class对象的一个实例
3）getName() 返回此Class对象所表示的实体（类、接口、数据类、基本类型或Void）名称
4）Class getSuperClass() 返回当前Class对象的父类的Class对象
5）Class[] getInterfaces() 返回当前Class对象所有的接口
6）ClassLoader getClassLoader() 返回该类的类加载器
7）Type getGenericSuperclass() 返回该类的泛型类，

8）通过class对象获取构造函数 Constructor 实例或者数组，获得 constructor 实例后，通过调用 newInstance() 方法来创建封装类的实例。
getConstructors() 获取公共的构造器，包括父类，是数组
getConstructor(Class<?>... params) 获取对应参数的公共构造器，包括父类。单个实例
getDeclaredConstructors() 获取自身所有构造函数，包含私有。数组
getDeclaredConstructor(Class<?>... params) 获取指定的构造函数。单个实例

9）通过class对象获取方法 Method，调用 method 内的 invoke(Object obj,Object... args) 方法执行封装实例的方法.
getMethods()  获取所有的public方法，包含父类的
getMethod(String name,Class<?>... parameterTypes)  获取所有的public方法，包含父类的
getDeclaredMethods() 获取自身所有的方法，包含私有的。
getDeclaredMethod(String name,Class<?>... parameterTypes) 获取指定方法

10）通过class对象 获取属性 Field，调用 Field 内的 get(obj)、set(obj,obj) getXXX(obj)、setXXX(obj,xxx) 方法获取/设置封装实例的属性。
getFields() 获取所有的public属性，包含父类的
getField(String name) 获取指定的公共属性，包含父类的
getDeclaredFields() 获取自身的所有属性，包含私有
getDeclaredField(String name) 获取指定属性，包含私有

setAccessible(true) 访问私有属性，在使用反射时，必须要设置此方法。

04.Type 类，获取泛型的真实类型，例如gson的TypeToken获取的type类型。
为什么必须要一个大括号，其实就相当于匿名内部类，他会在class编译时，自动转换成一个class类，会将泛型signature信息记录到class元数据中。

05.泛型类获取 Type，有四种实现：
1）TypeVariable：泛型类型变量，可以获取泛型上下限等信息。
2）ParameterizedType 具体的泛型类型，可以获得原数据中泛型签名类型（泛型真实类型）
3）GenericArrayType 泛型类是数组时，如List[],Map[]，此接口会作为Type实现。
4）WildcardType 通配符泛型，获得上下限信息。

第三节 代理模式
01.代理模式，分为静态代理，与动态代理（Proxy InvocationHandler）
1）静态代理包含：接口，实现类，包装类（包含实现类的代理类，同样继承接口，在相同的方法内调用实现类的方法），访问者。
缺点是扩展能力差，可维护性差

2）动态代理与静态代理的差别是在使用时通过一个中转类来动态生成包装类（代理类）。需要依赖以下两个类来实现。
他的结构包含：接口，实现类，Proxy.newProxyInstance() 方法结合 InvocationHandler 接口实现的动态包装类，访问者
Proxy是用来创建动态代理类的类。
InvocationHandler是给动态代理类实现的，负责处理调用接口里的方法。
3）优点是：由于其中代理类是使用代码自动生成，减少了重复类的创建。
缺点是：由于使用反射，所以效率比较低。应用场景局限，因为java的单继承特性（每个代理类都继承了Proxy类），即只能针对接口创建代理类，不能针对类创建代理类。

知识扩展：
proxy中的 getProxyClass0() 方法会判断接口长度是否超出65535的限制，会抛出 IllegalArgumentException 异常

Proxy.newProxyInstance()的三个参数
ClassLoader loader：类加载器
Class<?>[] interfaces：需要对接的接口，可以调用实例类来获取接口，有些实现类会继承多个接口；也可以用数据直接定死。xx.getClass.getInterfaces() 或者 new Class[]{接口.class}
InvocationHandler h ：方法的反射操作。method.invoke(实现类的实例，args)


第三章 多线程，锁以及锁原理，线程池
第一节 线程相关知识
01.CPU相关知识：
1）多核心：单芯片多处理器（Chip Multiprocessors，简称CMP），是有美国斯坦福大学提出的，其思想是将大规模并行处理器中的SMP（对称多处理器）集成到同一芯片内，各个处理器并行执行不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向，称为并行处理。
2）多线程：Simultaneous Multithreading。简称SMT，SMT可通过复制处理器上的结构状态，让同一个处理器上的多个线程同步执行并共享处理器的执行资源，可最大限度地实现宽发射、乱序的超标量处理，提高处理器运算部件的利用率，缓和由于数据相关或Cache未命中带来的访问内存延时。
3）CPU的核心数与线程的关系：一般一个核心对应一个线程，但是拥有超线程的核心可以一对二。
4）CPU的时间片轮转机制，是一种最古老、最简单、最公平且使用最广的算法，也称为RR调度。
每个线程被分配一个时间段，称作他的时间片，即该线程允许运行的时间。也就是把CPU的运行时间切片，不同的系统，时间片大小不一样。
时间到还在运行，CPU将被剥夺，所以sleep、yield等阻塞代码在执行时，虽然锁没有释放，但是CPU已经去执行别的线程了。

RR调度中损耗时间最大的可能就是线程切换（上下文切换），从一个线程切换到另一个，需要保存和装入寄存器值及内存映像，更新各种表格和队列等，一次大概消耗20000个CPU时间周期。1+1就相当于一个时间周期。
线程过多就会频繁切换线程，造成大量的上下文切换，会大量浪费CPU的性能，有可能还不如几条线程运行来得快（因为上下文切换的少呗）。
总结：时间片设的太短，会导致过多的线程切换，降低CPU效率，太长可能引起对短的交互请求响应变差。将时间片设为100毫秒通常是一个比较合理的折中。
在CPU死机的情况下，还能kill这个进程，应该就是因为RR调度。

02.什么是进程和线程
1）进程是操作系统在运行时进行资源分配的最小单位。系统给进程分配CPU、磁盘io、内存等资源。
2）线程是 CPU 调度的最小单位，必须依赖于进程而存在。线程启动缺省分配一兆的内存。
3）启动进程的同时，肯定会创建一个线程。多个线程共享进程的资源。
4）线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。

一个应用一个进程在Linux中最多可以启动1000个线程，window上最多启动2000个。
指定CPU跑某个线程、进程，需要调用Linux的内核来操作，java做不到，必须用C语言去写。

kthread进程是所有内核进程的父进程。
init进程：是所有用户（App）进程的父进程（或者父父进程）

03.并行和并发
1）并行是是同时运行。
与CPU是几线程的有关，如四核心八线程，就是并行8个线程。
2）并发是单位时间内能处理的线程数量。
例如：一条路每小时的最大车流量。
并发是通过时间片轮转机制实现的。一秒钟执行多少个时间片就是这个核心的并发数。

04.高并发编程的意义，好处和注意事项。
优点：高并发下，CPU可以执行更多的任务线程，可以提高下载速度，页面加载更快；可以使代码模块化，异步化。
缺点：多线程，同步不方便，容易死锁；线程过多会损耗服务器资源，容易造成死机宕机。

05.Java天生就是多线程的，一个main启动了六个线程
1）Monitor Ctrl-Break  监控Ctrl-break中断的信号
2）Attach Listener  内存Dump，线程dump，类信息统计，获取系统属性等
3）Signal Dispatcher  分发处理发送给JVM信号的线程
4）Finalizer  调用对象finalize方法的线程，可能会被Reference Handler提前杀掉，造成资源回收不了
5）Reference Handler 清除Reference的线程
6）main  主线程，程序入口。

06.线程的新建方法：两种
1）直接实现Thread。
2）实现Runnable，交给Thread去执行。
另一种形式是：实现Callable，交给FutureTask包装，再交给Thread执行。

07.FutureTask -> RunnableFuture -> Runnable,Future
说明：它是对具体的Runnable、Callable任务的执行、取消，查询是否完成，获取结果。
先执行的是runnable的run方法，在其中执行callable的call方法，获取返回值。
1）cancel(boolean):Boolean  取消任务
2）isCancel():boolean  是否取消
3）isDone():boolean  是否完成
4）get():V  获取返回结果，此方法会阻塞，直到任务返回结果
get(long,TimeUnit):V
5）done(): void 完成就会调用

08.Thread 与 Runnable、Callable的区别
1）Runnable 与 Callable 只是一个接口，内中方法也只是一个可以执行的普通方法。线程只有Thread一种。
2）继承自 Runnable 的 run 方法内检测 interrupt 通过 Thread.currentThread().isInterrupted();
3）Thread 继承自 runnable，一个类对应一个run方法。
4）实现 runnable 接口比继承 Thread 更灵活，适合多线程处执行同一个 run 方法。
5）增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。

09.为什么Thread 的 run 方法不用 synchronized 修饰
不同的 Thread 对象，就是不同的线程，run 方法自然也是在独立的线程中执行的，不会被争抢，所以无需加锁。

10.线程thread的六中状态
1)新建（new）
2)运行（runnable）：执行start之后，由于CPU的轮转机制会分为两种：就绪（ready）与运行中（running），两种状态统称为运行。
3)阻塞（Blocked）：等待获取锁
4)等待（waiting）：wait
5)超时等待（timed_waiting）：wait，sleep设置了超时时间。
6)终止（terminated）：执行完毕。

11.Thread 的方法
1）start()  启动线程，不可重复执行。只有执行了此方法，才实现了真正意义上的启动线程。加入就绪队列，等待调用 run 方法。
2）interrupt()  标记中断，Thread内不检测的话，就没用
3）isInterrupted() 对interrupt的检测，是否中断
4）static interrupted() 也是对interrupt的检测，但是为true时，执行了此方法，会将中断标记重置为false。目前实现为native方法，之前也是在内部调用的本线程的isInterrupted方法。
5）run()  执行任务，实现业务逻辑的地方，和普通方法无区别。
6）join() 插队，相当于两个线程同步执行。
join(long millis)
join(long millis, int nanos) 1毫秒等于一百万纳秒，所以这到底有啥用
7）yield() 让出CPU，进入就绪队列（可运行状态，让出时间不确定），等待CPU分配时间片。不会释放锁。
而且让出后有可能又会被立刻选中进入执行状态，因为线程切换（上下文切换），其他线程都需要重新加载。
8）sleep() 让出CPU，进入阻塞状态。不会释放锁。
static void sleep(long millis)
static void sleep(long millis, int nanos) 1毫秒等于一百万纳秒
9)static Thread currentThread() 返回对当前正在执行的线程对象的引用。
10）long getId() 返回该线程的标识符。
11）String getName() 返回该线程的名称。
12）int getPriority() 返回线程的优先级。
13）void setPriority(int newPriority)设置线程的优先级，只能在线程开始前设置。线程的优先级，由于系统原因，不能保证。所以没卵用。
14）boolean isAlive() 线程是否处于活动状态。
15）void setDaemon(boolean on) 将该线程标记为守护线程或用户线程，就是依赖关系。A线程在B线程中启动，A依赖于B，B结束的同时，A也会结束。

12. sleep、wait、yield、join的区别？
1）static sleep()，不释放锁，让出CPU；使线程进入睡眠状态，内部会进行中断标记检测，会抛出 InterruptedException 异常；睡眠结束后或者被中断捕获后，会进入就绪状态，等待CPU分配时间片。中断后，中断标记（interrupt）会被重置为false。
2）wait()，释放锁，让出CPU；使线程进入等待状态，内部同样会进行中断标记检测，会抛出 InterruptedException 异常；被notify/notifyAll唤醒或者中断捕获后，会进入就绪状态，等待CPU分配时间片。中断后，interrupt重置为false。
3）static yield()，不释放锁，让出CPU；因为是运行状态，所以不会抛出中断异常。在让出CPU的执行权后，如果CPU还有核心空闲，该线程又会被立即执行。
4）join()，抢锁，抢CPU，内部执行wait方法，等待加入，所以也会有中断标记检测，会抛出 InterruptedException 异常。抢到线程执行权后，相当于两条线程融合，同步执行，该线程执行完后，才会执行之前的线程。中断后，interrupt同样重置为false。
5）sleep() 是 Thread 类的方法，wait 是object的方法，wait，notify，notifyAll 只能在同步方法或者同步块里使用，而 sleep 可以在任何地方使用。

13.start() 与 run()的区别？
run方法只是函数调用，start执行后才是一个线程的启动。

14.threadLocal 介绍
说明：线程隔离，独有变量设定，需要static (final)修饰。因为每个线程都是自己独立的虚拟机栈，所以成员变量本身就是独有的，而类变量才是全局的，可以理解为单例的饿汉模式。
1）initialValue() 初始化变量，默认为空，调用get/set时才会执行，且只执行一次。
2）get()
3）set()  值变化后，需重新设置，否则还是 初始值。
4）remove() 回收当前线程的局部变量。即使不回收，线程结束后也将自动被垃圾回收。他的作用只是加快了内存回收的速度。

ThreadLocal本质上是在线程中创建了一个ThreadLocalMap，内部是Entry数组，key就是ThreadLocal对象本身。因为ThreadLocalMap本身就是线程独有的，所以不存在抢占问题，效率更高。

15.Thread 自己默认的锁机制
说明：等待与通知，调用synchronized锁定对象的wait与notify/notifyAll，且只能在synchronized修饰的方法内使用。推荐wait 与 notifyAll 搭配使用。
1）wait()  等待通知或被中断才会返回，让出CPU，释放锁。
wait(long) 超时返回
wait(long millis,int nanos)  超时返回。1毫秒等于一百万纳秒
2）notifyAll  通知所有在对象上等待的线程
3）notify  通知一个在对象上等待的线程，唤醒的是哪条线程不确定，只有一个线程的时候无所谓。

处于死锁状态下的线程无法被中断，但可以把进程干掉，单核单线程的也可以干掉，因为时间片轮转机制，但什么时候能轮到这个干掉线程，就没准了，所以会卡机老半天。

16.死锁的必要条件，怎么处理死锁。
1）循环等待
2）非抢占
3）互斥使用
4）占有并等待。
处理方法：
死锁避免--银行家算法：包含资源请求算法和安全性算法，死锁检测算法。

第二节 锁的使用
01.锁的种类：
1）是否需要加锁：乐观锁与悲观锁
2）是否阻塞：自旋锁/适应性自旋锁，阻塞
3）是否竞争：公平锁与非公平锁
4）是否可重入：可重入锁，不可重入锁
5）多线程是否可共享：共享锁，排它锁（目前接触的都是排它锁）
6）多线程竞争锁的级别：无锁，偏向锁，轻量级锁，重量级锁。

02.常用的锁：所有的锁都是悲观锁。
1）内置锁：synchronized 排它、可重入，非公平的
2）显示锁：接口Lock，实现类有：
ReentrantLock 排它、可重入、支持公平与非公平，默认非公平。
ReentrantReadWriteLock（ReadLock 与 WriteLock，两把锁）读可以多线程一起读，但不能写；写只能单线程写，也不能读。

03.接口：Lock：显示锁
1）lock()
2）lockInterruptibly() 可中断的获取锁，在锁的获取过程中可以中断当前线程的阻塞，会抛出 InterruptedException
3）tryLock()  尝试非阻塞的获取锁，调用该方法后立刻返回，能够获取返回true
4）tryLock(long)   超时获取锁，有三种情况：
当前线程在超时时间内获得了锁
当前线程在超时时间内被中断
超时时间结束，返回false。
5）unLock()
6）newCondition() 等待和通知机制

04.Condition 显示锁Lock对应的等待与通知。
1）await() 等待
awaitUninterruptibly()
await(long,TimeUnit)
awaitNanos(long)
awaitUntil(date)
2）signal() 通知单个，推荐使用的，因为可以定点唤醒。
signalAll() 多通知全部

05.synchronized：内置锁，wait与synchronized对应。
可以修饰代码块，成员方法，静态方法。
优点：使用简单便捷。
缺点：一旦开始获取锁，不能中断；没有超时机制；不能代码释放；容易死锁。

06.synchronized的锁的种类
1）对象锁：锁定对象本身实例或者对象中的其他成员变量的实例。
2）类锁：用 static 修饰的 synchronized 方法，锁的是这个实例对象的class实例。

07.类锁与对象锁的区别？
1）类的对象实例可以有多个，所以叫对象锁；
2）不同的对象锁是互不干扰的，类锁是唯一的。
3）如果锁定的成员变量是用static修饰的，他锁定的也只是这个静态对象，而不是它的class实例，所以也是对象锁。
4）类锁其实也是对象锁，类的class实例也是一个对象。

08.volatile 实现原理：
由 volatile 修饰的变量会存在一个"lock:"前缀指令，它会对CPU总线和高速缓存加锁（可以理解为CPU指令级的一种锁），同时该指令会将当前CPU缓存的数据写回到系统内存中，且这个写回操作会使在其他CPU核心里缓存了该内存地址的数据无效。
volatile：保证可见性，不保证原子性。所以它适合用于多读一写且互斥的情况，相当于超轻量级的 ReentrantReadWriteLock。

09.synchroinzed的实现原理？
synchronized在JVM的实现都是基于进入和退出 Mointor 对象来实现方法同步和代码块同步的，虽然具体实现细节不一样，但都是通过成对的 Monitorenter 和Monitorexit 指令来实现。

1）对同步块，monitorenter 指令插入在同步代码块的开始位置，monitorexit 插入到方法结束处和异常处。
JVM执行到该指令时，将会尝试获取对象 Monitor 的所有权，即尝试获得该对象的锁。
Monitor 的值为0，获取成功值变为1，重复进入累加1，释放后，也必须依次释放到变为0
获取失败，该线程进入阻塞状态，直到monitor的值变为0，再次尝试获取锁。

2）对同步方法，从同步方法反编译的字节码结果来看，方法的同步不是通过 monitorenter 与 monitorexit 指令来实现的，而是相对于普通方法，在常量池中多了一个 ACC_SYNCHRONIZED 标识符。
JVM通过该标识符来实现方法的同步。当方法调用时，将会先检查方法的 ACC_SYNCHROINZED 访问标志是否被设置，如果设置了，开始尝试获取 monitor 对象，之后和方法同步块的执行方式相同。

3）synchroinzed 的锁标志是存放在Java对象头里面的

10.synchronized 锁的级别
1）无锁状态：标志位：01
2）偏向锁：标志位：01，保存线程id，大量同一线程访问，方法块不加锁。加锁和解锁不需要额外的消耗，和执行非同步的方法比，仅存在纳秒级的差距。但如果线程间存在锁竞争，会带来额外的锁撤销的消耗，撤销偏向锁的时候还会导致 stw，所以只适用于大量同一线程访问同步块的场景。
3）轻量级锁：标志位：00，非同时多线程访问，id不同，锁启动。竞争的线程不会阻塞，提高了程序的响应速度。如果始终得不到锁，竞争的线程使用自旋会消耗CPU，所以会有一个次数限制。追求响应速度，同步块执行速度非常快。
4）重量级锁：标志位：10，多线程同时访问，线程竞争不使用自旋，不会消耗CPU。线程阻塞，响应时间缓慢。追求吞吐量，同步块执行速度时间较长。

11.自旋锁
不挂起线程，尝试获取锁的方式处于自旋状态，如有锁释放，可以立即拿到锁，相当于省去了线程挂起和再次加载的时间。
但自旋时间不能过长，通常设为线程挂起和加载一次的时间，因为他节省的就是这点时间，超标了就没意义了。
适应性自旋锁：
Java1.5之前是默认自旋10次后挂起，1.6后根据上一个的自旋时间以及获得锁的线程的操作时间来决定。但绝不会超过一个线程上下文切换的时间。

12.Synchronized 做了哪些优化 （京东）
引入如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁、逃逸分析等技术来减少锁操作的开销。
逃逸分析:如果证明一个对象不会逃逸方法外或者线程外，则可针对此变量进行优化.
同步消除 synchronization Elimination，如果一个对象不会逃逸出线程，则对此变量的同步措施可消除。
锁消除和粗化
锁消除：虚拟机的运行时如果检测到一些要求同步的代码上不可能发生共享数据竞争，则会去掉这些锁。
锁粗化：将临近的代码块用同一个锁合并起来。
消除无意义的锁获取和释放，可以提高程序运行性能。

13.什么是CAS（Compare And Swap）乐观锁？
内存地址V，以及当前地址上的值A，线程操作值变为B后，要把B写回到内存中，此时内存上值A没变的话，就赋值B；变了，重新分配再循环比较一次。
通俗解释：拿到oldVale，执行指令获得newValue，写回数据时，比较oldValue是否改变，未改变写回newValue；改变了，重新分配再循环比较一次。

14.CAS乐观锁原理，怎么保证两个线程同时进行比较？
这个是硬件CPU层面保证的。可以理解为：CPU保证了只有第一个进入的线程看到的是old值，其他线程看到的都是old+1。

15.CAS产生的问题：
1）ABA问题，A申请时，B先使用并修改成B，但完成后就又还原了，此时A开始修改。加一个版本号就可以解决。
2）开销问题，ThreadLocal最快，CAS次之，锁最慢。
3）只能保证一个共享变量的原子操作。

16.JDK中CAS相关原子性操作的使用，凡是带Atomic的都是。
1）更新基本类型类：AtomicBoolean，AtomicInteger，AtomicLong
2）更新数组类：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray
3）更新引用对象类型：AtomicReference，AtomICMarkableReference，AtomicStampedReference

第三节 锁的原理 AQS
01.什么是AQS？
AbstractQueuedSynchronizer，队列同步器，显示锁的内部实现以及一些同步组件的实现就是基于AQS实现的。
AQS内部使用了一个int类型的state变量表示同步状态，默认0，通过内置的FIFO队列来完成线程的排队工作。
AQS的设计模式是模板方法模式。

02.自定义AQS。
需要重写tryAcquire()，tryRelease() 方法，内部同时需要参与的还有三个方法：
1）getState()：获取状态
2）compareAndSetState()：比较并设置状态
3）setState()：state不为0时，属于同一线程再次进入与退出，都需要通过 setState 来设置 state。

独占式锁需要实现的方法：最后都会调用tryAcquire方法
1）acquire(int acquires)：独占式同步状态，内部调用tryAcquire方法
acquireInterruptibly(int acquires)：支持中断检测
2）boolean tryAcquireNanos(int acquires,long nanos)：超时限制。
1）tryRelease(）release方法中会调用，需要把state释放到0，才会真正释放。

共享式获取锁需要实现的方法：tryAcquireShared() 与 tryReleaseShared()
1）acquireShared(int acquires)：共享式获取同步状态，同一时刻，可以有多条线程获取到同步状态。
acquireSharedInterruptibly：中断检测；
2）boolean tryAcquireSharedNanos()
3）tryReleaseShared()：releaseShared方法中会调用，需要把state释放到0，才会真正释放。

getQueuedThreads()：获取等待在同步队列上的线程集合。
isHeldExclusively()：是否被当前线程所独占。
hasQueuedPredecessors()：当前队列检测

03.AQS的基本思想CLH队列锁
CLH队列锁：Craig Landin and Hagersten Locks
CLH队列锁也是一种基于链表的可扩展、高性能、公平的自旋锁。申请线程仅仅在本地变量上自旋，不断轮询前驱结点的锁状态，前驱释放锁后，拿到锁，结束自旋。
AQS是CLH队列锁的一种变体实现。

04.ReentrantLock的实现
内部类Sync实现了AQS锁，并重写了tryRelease方法。又派生了两个AQS锁，一个公平FairSync，一个非公平NonfairSync。
FairSync中重写了 tryAcquire 方法，内部第一次获取锁时，会有排队检测 hasQueuedPredecessors，没有就尝试获取锁，有就加入队列。
NonfaitSync内部的 tryAcquire 调用的是Sync中的 NonFairTryAcquire 方法。

05.锁的公平与非公平
线程在尝试获取锁时，公平锁会先检测线程同步队列，队列中有等待线程，公平锁会把此线程放到队尾；
非公平锁会先让此线程尝试拿锁，拿不到，才会加入队列队尾；拿到了，那就直接执行。
获取锁的时候，涉及到线程的挂起与唤醒，也就是上下文切换，所以非公平锁比公平锁性能更快。

第四节 线程池原理
01.线程池的好处
1）降低资源消耗。通过重复利用已创建的线程，降低线程创建和销毁的消耗。
2）提高响应速度。因为线程已创建，可以立即执行新加入的任务。
3）提高线程的可管理性。线程启动内存缺省一兆大小，启动太多，不仅会消耗系统资源，还降低系统的稳定性，使用线程池进行统一分配、调优和监控。

02.JDK中的线程池的创建
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)
1）corePoolSize    默认核心线程的数量，默认是未创建的。但是当线程池执行了prestartAllCoreThreads()方法后，会提前创建并启动所有核心线程。
2）maximumPoolSize 允许最大线程的数量，当队列workQueue满了之后，继续提交任务，就会创建新的线程。
3）keepAliveTime   默认来说是非核心线程的存活时间。核心线程创建后，一直存活。但当 allowCoreThreadTimeOut(true) 设为true时，核心线程也会被回收。
4）unit            keepAliveTime的时间单位
5）workQueue       线程队列，它是阻塞队列。核心线程都在执行任务时，继续提交的任务就会进入阻塞队列中等待。通过workQueue，线程池实现了阻塞功能。
6）threadFactory   创建线程的工厂
7）handler         饱和策略，默认是抛出异常。最大线程满载时还提交任务，就会抛出。

03.线程池的工作机制
1）生产者提交任务，创建核心线程执行任务。
2）核心线程满载时，开始往阻塞队列（workQueue）中添加。
3）workQueue也达到上限时，开始创建新线程执行。
4）最大线程也达到上限时，如还有任务提交，会执行线程池的饱和策略 RejectedExecutionHandler，默认的是直接抛出异常。

04.ThreadFactory 创建线程的工厂
Executors静态工厂里默认的threadFactory线程的命名规则是：pool-数字-thread-数字

05.饱和策略 RejectedExecutionHandler
说明：核心线程满载，阻塞队列满载，最大工作线程满载，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了四种策略。
1）AbortPolicy：直接抛出异常，默认策略。
2）CallerRunsPolicy：用生产者自身线程来执行任务。
3）DiscardOldestPolicy：丢弃阻塞队列中最靠前的任务，并执行当前任务。
4）DiscardPolicy：直接丢弃该任务。
5）自己实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。

06.常见的线程池：AsyncTask，HandlerThread，IntentService，ThreadPoolExecutor。
allowCoreThreadTimeOut 在 ThreadPoolExecutor 中；
1）Executors.newFixedThreadPool(5)，都为核心线程且数量固定，可以用allowCoreThreadTimeOut设置超时机制，这样和非核心线程也就没啥区别了。
2）Executors.newCachedThreadPool()，无核心，非核心不限，有超时机制60s，适合多图加载这种文件小而多的任务。
3）Executors.newScheduledThreadPool(5)，核心固定，非核心不限，闲置时超时回收，主要用于执行定时任务和具有固定周期的重复任务。
4）Executors.newSingleThreadExecutor()，仅创建一个单核心线程，任务串行。

Scheduled 预订

Executor 是线程池接口，ExecutorService 是派生接口，ThreadPoolExecutor 是接口的实现类。
Executors 是线程池的实现方法汇总。

07.线程池的方法
1）execute()用于提交不需要返回值的任务。
2）submit()用于提交需要返回值的任务。他返回的是一个Future对象。
3）shutdown() 关闭线程池
shutdownNow（）会返回等待执行的任务列表。
4）isShutdown() 为true，代表线程池开始关闭，关闭成功后，isTerminated() 方法会返回true

08.合理配置线程池，需要分析任务特性。
1）任务的性质：CPU密集型（计算相关）；IO密集型（IO流）；混合型
2）任务的优先级：高中低
3）任务的执行时间：长中短。
4）任务的依赖性：是否依赖其他系统资源，如本地文件，数据库。

CPU密集型：计算相关，所以快，应该配置尽可能少的线程，防止线程切换造成的资源浪费。配置：cpu核心数+1
IO密集型：涉及io操作，执行时间一般较长，可以多配置一些。通常：2*cpu核心数
混合型：两者执行时间相差不大那就拆分开，变成两个任务去执行，一定比两者串行要快；相差过大，那就无所谓了。

之所以加1，是防止有页缺失（内存中无数据，需要到虚拟（硬盘）中读取数据）的线程，CPU可以立马获取下一个等待线程。
Runtime.getRuntime().availableProcessors()  当前可用的逻辑核心数

第五节 Java内存模型 JMM(Java Memory Model)

    操作                   时间
1.6GZ的CPU执行一条指令      0.6纳秒
CPU读取的一级缓存           1.2纳秒
CPU读取的二级缓存           5.5纳秒
CPU读取的三级缓存           15.9纳秒
CPU读取一次内存             100纳秒/59.4ns
1G网卡，网络传输2Kb         20微妙
从内存连续读取1M数据         250微秒
从固态盘顺序读1M数据         0.3毫秒
从机械盘顺序读1M数据         2-10毫秒
数据库查一条记录（有索引）    十几毫秒
打开一个站点                几秒

1秒=1000毫秒
1毫秒=1000微秒
1微秒=1000纳秒

01.计算机的缓存级别
1）L0寄存器，L1，L2，L3，与CPU集成在一起。L1中还分为一级数据缓存（Data Cache，D-Cache,L1d）和一级指令缓存（Instruction Cache，I-Cache,L1i），分别用于存数据和执行数据的指令解码。
每个核心拥有独立的运算处理单元，控制器、寄存器、L1、L2缓存。CPU整体核心共享L3缓存。
2）L4主存：就是内存条
3）L5硬盘
4）服务器

02.JMM模型
主内存中存有全部变量，每个线程都有自己的私有工作空间（栈）。这就涉及到线程间的数据同步问题。
由于CPU的时间片轮转机制，CPU在执行完某一条指令后，就会切换任务。而一句java代码，往往对应多条CPU指令。
volatile 的问题就出在这里，一条代码生成的多条指令没有彻底执行完毕，就转去执行其他线程了，造成同步问题。


第四章 序列化
第一节 序列化（Encode）与反序列化（Decode）
01.序列化（Encode）与反序列化（Decode），是将数据对象转成相应的格式与把相应的格式再次转换成数据对象的一个过程。
反序列化后获得的对象与前对象不是同一个对象，它会在堆内存上重新分配位置。

02.序列化协议特性
1）通用性：可以跨平台，跨语言
2）强健性：
3）可调式性/可读性：支持面广，
4）性能：时间开销/读取快，空间开销/占地小
5）可扩展/兼容性
6）安全性/访问限制

03.常见的序列化协议
1）XML&SOAP：SOAP是基于XML为序列化和反序列化协议的结构化消息传递协议。
2）JSON（JavaScript Object Notation）：产生于JavaScript
XML所产生的的序列化文件大小约等于JSON的两倍。解析速度更快，扩展性和兼容性更好。
3）Protobuf：更快，更小。
序列化后的数据量约为XML的1/3到1/10。
解析速度更快，比XML快20-100呗
动态库非常友好，使用简洁，反序列化只需要一行代码。

04.Serializable
1）Serializable 是 JDK提供的原生序列化接口，需要与ObjectOutputStream 与 ObjectInputStream 配合使用；
2）静态成员变量属于类不属于对象，不参与序列化，值是跟随当前Java文件定义走的。
3）用transient关键字标记的成员变量不参与序列化。
4）FileUtils中serialize(path,value)（序列化）与deserialize(path)（反序列化）运用。

05.serialVersionUID 与 兼容性
private static final long serialVersionUID =1L;
类版本对应，必须相同，此属性特殊，值会随着类元数据输出。
当前类修改了，这个值不能变，否则会报错 InvalidClassException

Invalid 无效的

kotlin 代码在伴生类中：
companion object {
private const val serialVersionUID = 1L
}

06.Externalizable 继承自 Serializable，有两个方法，
1）writeExternal(ObjectOutput object)：写出数据
2）readExternal(ObjectInput object)：读入数据

07.Serializable 序列化步骤与数据结构
1）将对象实例相关的类元数据输出。
2）递归的输出类的所有超类描述。
3）从最顶层的超类开始依次输出对象实例的实际数据值。

08.ObjectOutputStream 与 ObjectInputStream
1）writeObject()：对象改变后再次写入需要搭配 WriteUnShared 方法，或者 reset() 重置后，在调用writeObject
2)readObject()：写入几个，最多读取几个，不能超限。超出会报错：NotSerializableException。

09.ObjectOutputStream(out)：的参数有两种
1）是FileOutputStream：代表把数据保存成文件；
2）是ByteArrayOutputStream：代表把数据转成byte数组：bos.toByteArray()。
3）可以把byte数组交给 ObjectInputStream(ByteInputStrean(byte) 处理，这样可以实现数据的深复制。但此方法是IO操作，不推荐。

10.重写 Serializable 的四个方法
writeReplace() -> writeObject() -> readObject() -> readResolve()
writeReplace 先于 writeObject
readResolve 后于 readObject

11.Parcelable
Parcelable 是 Android 特有的，只在内存中使用，也可以在跨进程中使用。需要重写一个方法，一个接口，在 CourseEntity 中有应用。
parcelable 通过 writeToParcel 把当前对象转成 Parcel 对象；
通过 createFromParcel 把 Parcel 对象转成对象，从而实现了序列化和反序列化

1）方法：writeToParcel(Parcel dest,int flag)：将当前对象转换成dest
dest.writeString(this.name)：转成对应的属性。
2）接口：Parcelable.Creator：实现内部的两个方法
createFromParcel(Parcel source) = new 构造方法(source)
newArray(int size)= new Array<XXX>[size]

12.Serializable 与 Parcelable 比较：
Serializable 是Java提供的序列化接口，使用简单但开销大，因为 Serializable 在序列化过程中使用了反射机制，会产生大量临时变量，从而导致频繁GC。并且数据的读写过程是IO流的形式，操作的是内存、硬盘或网络。
Parcelable 则是以Binder作为信息载体，内存开销较小，且他的读写都是在内存上操作，速度更快，因此在内存间进行数据传递时，推荐使用Parcelable。需要对数据进行持久化或者网络传输时，用 Serializable

13.Android 里面为什么要设计出 Bundle 而不是直接用 Map结构
Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数据对应下标，一个对象数组保存key和value，内部使用二分法对key进行排序，所以在添加、删除、查找数据的时候，都会使用二分法查找，只适合于小数据量操作，如果在数据量比较大的情况下，那么它的性能将退化。
而HashMap内部则是数组+链表结构，所以在数据量较少的时候，HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据量，我没见过在两个Activity之间传递10个以上数据的场景，所以相比之下，在这种情况下使用ArrayMap保存数据，在操作速度和内存占用上都具有优势，因此使用Bundle来传递数据，可以保证更快的速度和更少的内存占用。
另外一个原因，则是在Android中如果使用Intent来携带数据的话，需要数据是基本类型或者是可序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。
而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为了更加快速的进行数据的序列化和反序列化，系统封装了Bundle类，方便我们进行数据的传输。

14.Android中Intent/Bundle的通信原理及大小限制
Intent 中的 Bundle 是使用 Binder 机制进行数据传送的。能使用的 Binder 的缓冲区是有大小限制的（有些手机是 2 M），而一个进程默认有 16 个 Binder 线程，所以一个线程能占用的缓冲区就更小了（ 有人以前做过测试，大约一个线程可以占用 128 KB）。
所以当你看到 The Bindertransaction failed because it was too large 这类 TransactionTooLargeException 异常时，你应该知道怎么解决了

15.为何Intent不能直接在组件间传递对象而要通过序列化机制？
Intent在启动其他组件时，会离开当前应用程序进程，进入 ActivityManagerService 进程（intent.prepareToLeaveProcess()），这也就意味着，Intent所携带的数据要能够在不同进程间传输。首先我们知道，Android是基于Linux系统，不同进程之间的java对象是无法传输，所以我们此处要对对象进行序列化，从而实现对象在 应用程序进程 和 ActivityManagerService进程 之间传输。
而Parcel或者Serializable都可以将对象序列化，其中，Serializable使用方便，但性能不如 Parcel容器，后者也是Android系统专门推出的用于进程间通信等的接口。

第二节 Gson解析汇总
解析原理基于事件驱动
其他json解析还有：FastJson，Jackson
01.基类JSonElement，四种类型：
1）JsonPrimitive：八种基本类型与 String 最后都是以JsonPrimitive（也就是JsonElement）存入json中的。
2）JsonObject：其中的存在形式都是：key:JsonElement，经过addProperty方法，所有类型都会封装进JsonPrimitive中。
3）JsonArray：JsonElement的集合。
4）JsonNull：值为空。

02.注解：都和字段过滤相关；
1）@SerializedName：json语句与实体类里的名称不一致时使用，json序列化与反序列化时的名称替换；alternate：其他名称。
2）@Expose：是否可序列化，搭配 GsonBuilder 中的 excludeFieldsWithoutExposeAnnotation() 方法使用，默认为true，序列化与反序列化可单独设置。
3）@Since(1.2)与@Until(1.4)：从1.2这个版本开始使用；到1.4这个版本为止停止使用，这两个注解需要搭配GsonBuilder的serVersion(1.0)来使用。
4）@JsonAdapter：类的注解，支持TypeAdapter，TypeAdapterFactory，JsonSerializer，JsonDeserializer；使用此注解后就无需 registerTypeAdapter 等注册，他会自动注册的，且优先级更高。

03.JsonSerializer 与 JsonDeserializer：序列化（实体转json）与反序列化（json转实体），两者合起来就是 @SerializedName，需要搭配 GsonBuilder的registerTypeAdapter 或者 @JsonAdapter 来使用。

04.使用方法介绍，参考GsonUtils类
GsonBuilder builder = new GsonBuilder();
01）builder.excludeFieldsWithoutExposeAnnotation();//需要与@Expose搭配使用
02）Modifier，过滤字段
builder.excludeFieldsWithModifiers(Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL);//排除这些修饰符修饰的属性
03）setFieldNamingPolicy 与 setFieldNamingStrategy，既能过滤也能匹配，级别低于@SerializedName。
@SerializedName注解拥有最高优先级，在加有 @SerializedName 注解的字段上 FieldNamingStrategy 不生效！
builder.setFieldNamingPolicy(FieldNamingPolicy.IDENTITY);
builder.setFieldNamingStrategy(new FieldNamingStrategy() {
    @Override
    public String translateName(Field f) {
        String name = f.getName();//对应字段的名称，如需要更换名称则自行处理
        if ("name".equals(name)) {
            return "activityName";
        } else if ("component".equals(name)) {
            return "componentName";
        } else if ("des".equals(name)) {
            return "describe";
        } else if ("image".equals(name)) {
            return "img";
        } else if ("version".equals(name)) {
            return "version";
        } else {
            LogUtils.i("name==" + name);
            return name;
        }
    }
});
04）自定义排除字段，true为排除，可根据具体的字段具体排除，也可直接排除类。
        builder.addSerializationExclusionStrategy(new ExclusionStrategy() {//序列化时排除
            @Override
            public boolean shouldSkipField(FieldAttributes f) {
                return false;
            }

            @Override
            public boolean shouldSkipClass(Class<?> clazz) {
                return false;
            }
        });
05）builder.addDeserializationExclusionStrategy(new ExclusionStrategy() {//反序列化时排除
    @Override
    public boolean shouldSkipField(FieldAttributes f) {
        return false;
    }

    @Override
    public boolean shouldSkipClass(Class<?> clazz) {
        return false;
    }
});
06）根据版本来排除
builder.setVersion(1);//与@Since(1.2)或@Until(1.4)搭配使用才有效果

其他常用方法
07）builder.serializeNulls();//属性值为空时输出 key:null
08）builder.setPrettyPrinting();//tojson输出时，格式化json字符串
09）builder.setDateFormat("yyyy-MM-dd");// 设置日期时间格式，另有2个重载方法,在序列化和反序化时均生效，个人感觉没什么用
10）builder.disableInnerClassSerialization();// 禁此序列化内部类
11）builder.generateNonExecutableJson();//生成不可执行的Json（多了 )]}' 这4个字符）
12）builder.disableHtmlEscaping();//禁止转义html标签


第五章 IO流 与 AES加密加固
第一节 IO流
01.Java.io包的分类
1）流式部分：InputStream，OutputStream，Reader，Writer
2）非流式部分：File、RandomAccessFile、FileDescriptor等
3）其他：文件读取部分的与安全相关的类，如 SerializablePermission 类，以及与本地操作系统相关的文件系统的类，如：FileSystem 类和 Win32FileSystem 类和 WinNTFileSystem 类。

02.IO流的分类
1）按流向分:
输入流: 程序向内读取数据的流。
输出流: 程序向外输出数据的流。
2）按数据传输单位分:
字节流: 以字节（byte，8位 == 8bit）为单位传输数据的流，通常用来读取二进制数据，如图象和声音（png，exe，zip）。
字符流: 以Unicode字符（char，16位）为单位传输数据的流，通常用来读写文本信息（json，xml）。
字符流读入的时候是把字节流转成了字符流，写出的时候又把字符转成了字节写出。
3）按功能分:
节点流: 用于直接操作目标设备的流
过滤流/包装: 是对一个已存在的节点流的连接和封装，提供对数据的缓存，转码等功能，提升性能。

03.InputStream：输入流，字节流，单位：字节byte（8位 == 8bit）
1）ByteArrayInputStream：接收byte数据
2）ObjectInputStream
3）FileInputStream()：参数可以是File，也可以是FileDescriptor
4）PipedInputStream
5）FilterInputStream：
BufferedInputStream：带缓冲区的IO
DataInputStream：可直接转换成对应数据类型的IO

04.OutputStream：输出流，字节流，单位：字节byte（8位）
1）ByteArrayOutputStream：把数据转成byte数组
2）ObjectOutputStream
3）FileOutputStream
4）PipedOutputStream
5）FilterOutputStream
BufferedOutputStream
DataOutputStream
PrintStream

05.Reader：输入流，相当于对字节流的二次封装，单位：字符char（16位）
1）CharArrayReader
2）PipedReader
3）FilterReader
4）BufferedReader：可以读一行：readline()
5）InputStreamReader：将 InputStream 转成 Reader，可指定编码格式
文件实现类：FileReader

06.InputStreamReader 内部是对 StreamDecoder 的封装
1）使用指定的或默认的编码集将 字节 解码为 字符
2）StreamDecoder 内通过 read 方法将解码后的 字符 读取到程序中。

07.Writer：输出流，相当于对字节流的二次封装，单位：字符char（16位）
1）CharArrayWriter
2）PipedWriter
3）FilterWriter
4）BufferedWriter
5）OutputStreamWriter：将 OutputStream 转成 Writer，可指定编码格式
文件实现类：FileWriter
6）PrintWriter

08.OutputStreamWriter 内部是对 StreamEncoder 的封装
1）使用指定的或默认的 编码集 将 字符 转码为 字节。
2）StreamEncoder 内通过 writer 方法将转码后的 字节 写出到底层字节输出流中。

09.为什么要使用 buffered 缓冲器？
字节流与字符流每次读写的只有一个字节或一个字符，与硬盘交互次数太频繁。
buffered内部有缓冲区，每次可以从硬盘读写一定量数据，交互次数明显下降，提高使用效率。

10.RandomAccessFile
可读可写，也可以指定位置读写，可用于多线程下载文件，文件断点下载/续传
1）mode：r代表可读，w代表可写，rw代表可读写。还有rws，rwd。
2）seek(index)：将指针移动到此位置开始读写。
3）setLength(length)：设置文件长度/大小
4）skipBytes(num)：跳过多少长度

11.NIO的Channel
FileChannel配合着ByteBuffer，其实就是个缓冲区，和buffered缓冲以及自己定义的byte数组缓冲一样，效率基本没差。

12.DataOutputStream(BufferedOutputStream(FileOutputStream(file)))
FileOutputStream 是字节流，为了提升访问效率，所以又包装了一层 BufferedOutputStream，为了实现与机器类型无关的Java基本类型数据的输出，所以又包装一层DataOutputStream。
一层包一层就是装饰模式。

13.开发中使用字节流好还是用字符流？
在所有硬盘上保存文件或进行传输的时候都是按字节进行的，包括图片文字都是按字节完成的，字符流是在内存中对字节流包装后才形成的，所以字节流的操作是最多的。
所以拷贝文件是，应选用字节流进行操作。

第二节 AES加密加固
01.什么是反编译
利用编译程序从源语言编写的源程序产生目标程序的过程。
zip解压apk，用dex2.jar工具将dex文件转成jar文件，用jd-gui看jar包，查看class文件。

02.加固方案
1）反模拟器：
2）代码虚拟化：自建一个虚拟执行引擎，然后把原生的可执行代码转换成自定义的指令进行虚拟执行。
3）加密：代码分块加密，使用时在逐级解密。

03.对称加密与非对称加密
1）对称加密：加密和解密使用的秘钥是同一个：
DES,3DES,Blowfish,IDEA,RC4,RC5,RC6,AES
2）非对称加密：公钥与私钥是一对，公钥加密，私钥解密；私钥加密，公钥解密。因为解密加密是两个秘钥，所以叫非对称加密算法。

04.Apk文件的组成
1）META-INF文件夹：签名信息
2）res文件夹：资源信息
3）class.dex：相当于jar包，java类文件压缩包，需要加密的部分。
4）resources.arsc：资源对照信息
5）AndroidManifest.xml

04.Dex文件的组成部分
1）文件头：header
2）索引区：
string_ids：字符串索引
type_ids：类型索引
proto_ids：方法原型索引
field_ids：域的索引
method_ids：方法索引
3）数据区
class_defs：类的定义区
data：数据区
link_data：链接数据区


第六章 JVM虚拟机的原理
第一节 了解JVM（Java Virtua; Machine）
01.为什么要了解JVM虚拟机？
jvm不只支持java，也支持scala、kotlin、groovy。
区块链2.0--以太坊（比特币是区块链1.0）中提供了evm虚拟机，它的实现和jvm类似，基于栈，生成脚本编译成字节码来执行。

02.虚拟机的种类
1）HotSpot：热点代码探测技术，及时编译器（发现最有价值的代码，如果代码用的非常多，就会把这些代码编译成本地代码）。
2）华为有的项目用的J9。
3）谷歌：Google Android Dalivk VM

03.未来的Java技术
1）模块化：使用的最多OSGI，应用层面就是微服务，互联网的发展方向。
2）混合语言：多个语言都可以运行在JVM中。
3）多核并行CPU从高频次转变为多核心，多核时代，jdk1.7引入了fork/join，JDK1.8提出lambda表达式（函数式编程天生适合并行运行）
4）丰富与法：JDK5提出自动装箱、泛型、动态注解等语法。JDK7二进制原生支持。try-catch-finally至try-with-resource
5）64位虽然同样的程序64位内存消耗比32位要多一点，但是支持内存大，所以虚拟机都会完全过渡到64位。
5）更强的垃圾回收机制：JDK11-ZGC(TB级别内存回收)：有色指针、加载屏障

04.JVM、JRE、JDK的关系
JVM 只是把Clss文件翻译成机器识别的代码，它的运行需要依赖很多类库，这时就需要用到JRE。
JRE（Java Runtime Environment）内含很多基础类库。Java运行时环境就是由JVM标准加上实现的基础类库组成的。
JDK 包含调试代码，编译代码（javac），打包代码，反编译代码（javap）这些工具。

05.JVM中类的完整生命周期
java源文件 -> class文件（javac打包成java字节码） -> JVM转成机器码 -> 系统创建class对象 -> 实例对象 -> 卸载；周而复始。

第二节 JVM的构成
Stack 与 Heap 都运行在内存上，在内存空间上字节码指令不必担心不同机器上的区别，所以JVM实现了与平台无关的特性。

01.运行时数据区域：五部分
1）虚拟机栈、本地方法栈（native方法）、程序计数器：指令相关，线程私有，随线程产生和消亡。编译时确定所需内存大小
2）堆区、方法区/元空间：数据相关，线程间共享。

02.程序计数器
当前线程正在执行字节码的行号指示器。内存空间较小，各线程之间独立存储，互不影响。

03.为什么需要程序计数器？
java是多线程的，同时 CPU 有一个时间片轮转机制，这意味着线程切换，程序计数器确保了多线程情况下，程序的正常执行。

04.虚拟机栈：存储当前线程运行方法所需的数据。相当于一个栈帧的集合。栈的大小缺省为1M，栈结构。（大小设置 -Xss）
1）每个线程私有的，线程运行时，在执行每个方法的时候都会打包成一个栈帧。
2）栈帧包含：局部变量表、操作数栈、动态链接、方法出口（返回地址）、栈上分配的对象（逃逸分析）。
3）每个时刻正在执行的当前方法就是虚拟机栈顶的栈帧。
4）方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。

栈的大小可用参数 -Xss 调整大小，例如-Xss256M
栈中也可以抛出 OutOfMemoryError，这是系统创建了过多的线程，在分配栈内存时，不够用了，就oom了，系统会死机。

javac xxx.java 编译成class文件
javac -classpath compiler.jar(自定义的APT) xxx.java(目标文件) yyy.java(注解文件)
javap -c x.class 查看字节码
javap -v x.class 查看详细的字节码
javap -v x.class文件 > 1.txt 转成对应的txt文件
后缀 > x.txt 可以把需要查看的字节码存储到对应的文件中。
https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html
字节码助记码解释地址：https://cloud.tencent.com/developer/article/1333540

05.栈帧的构成：
1）局部变量表（Local Variable Table）：
在编译程序代码的时候就可以确定栈帧中需要多大的局部变量表，具体大小可在编译后的class文件中看到。
局部变量表的容量以 Variable Slot（变量槽）为最小单位，每个变量槽都可以存储32位长度（4字节）的内存空间，用于存放八大基本数据类型和对象的引用变量（所以引用变量永远是4 Byte/字节，对象在堆中）。如果是64位的就用高低位/前后位占用两个也可以放下。
2）操作数栈：栈结构，在编译期就可以确定大小，栈上分配应该也可以在此阶段确定。
操作元素可以是任意的java数据类型，执行期间会一直进行入栈出栈的操作。
3）动态链接：
存放编译时不能确定方法入口的方法地址，需要在运行时来保证方法调用的正确性。如动态特性（groovy、JS、动态代理），native方法，常量池。
4）返回地址：
正常返回（调用程序计数器中的地址作为返回）；异常返回（通过异常处理器<非栈帧中的>来确定）。
5）栈上分配：
现在的虚拟机一般都有逃逸分析，如果这个对象的作用域只在方法内，就会在栈上分配。因为栈帧在出栈时就会被回收。

在JVM中，基于解释执行的这种方式是基于栈的引擎，这个栈就是操作数栈。

06.本地方法栈：保存的是native方法的信息。
在JVM中线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，JVM只是简单地动态链接，并直接调用native方法。
各自虚拟机自由实现，在HotSpot中本地方法栈和虚拟机栈合二为一。

07.线程共享的区域：方法区/永久代（1.7之前叫这个）/元空间（1.8之后叫这个），用来存放已被虚拟机加载的类相关信息，内含：
1）类信息；
2）即时编译期编译后的代码；
3）常量：final 修饰的，可分为直接常量和符号常量
直接常量就是具体的数值（八种基本类型）
符号常量：符号化的常量，就是给直接常量起个名。
4）静态变量/类变量：1.7之后在堆中（物理上），逻辑上还是属于方法区的。
5）运行时常量池：在编译期可以确定的在常量池中，运行期才能确定的新字符串，是在堆中的。1.7之后都在堆中，位置不同而已。
常量池包含：运行时常量池，class常量池、字符串常量池

08.方法区的加载过程：
JVM 在执行某个类时，必须先加载。在加载类（加载、验证、准备、解析、初始化）的时候，JVM会先加载 class 文件。
在 class 文件中除了有类的版本、字段、方法和接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期间生成的各种字面量和符号引用。
字面量包括字符串（String a="b"）、基本类型的常量（final 修饰的常量），符号引用则包括类和方法的全限定名（例如 String 这个类，它的全限定名就是 Java/lang/String）、字段的名称和描述符以及方法的名称和描述符。
当类加载到内存中后，JVM会将 class 文件常量池中的 符号引用 存放到运行时常量池中；在类解析之后，JVM 会把 符号引用 替换为 直接引用（对象的索引值）。
加载完 class 后，会给这个 class 对象分配索引值的。运行时常量相同内容的只会有一份。

09.方法区的变化
Java 1.7之后，将永久代中的静态变量和运行时常量池转移到了堆中，Java8后将永久代移除了，改用 元空间（class metadata）代替，元空间存储的位置是本地。
他们逻辑上还是属于方法区的，但是实际位置在堆区。

可用以下参数调整：
JDK7以前：-XX:PermSize=?; -XX:MaxPermSize=?;
JDK8以后：-XX:MetaspaceSize=?;-XX:MaxMetaspaceSize=?;
JDK8以后大小就只受本机总内存的限制。

10.为什么要用元空间代替永久代，好处是什么？
官方的解释是为了融合HotspotJVM 与 JRocKitVM，后者是没有永久代的，所以不需要配置永久代。
永久代在JDK1.7中在指定的 PermGen 区大小只有8M，JVM加载的 class 过多就会内存溢出，抛出 java.lang.OutOfMemoryError：PermGen。因为加载 class 的数量不确定，分配空间不确定，每次 FullGC 的时候都可能被收集，回收效率也低。

11.线程共享的区域：堆区：垃圾回收发生的主要区域
数组以及几乎所有的对象都在堆上。
基本数据类型，有两种情况，作为局部变量时，在所在方法体栈帧的局部变量表里。作为成员变量都是随所在对象在堆中。
static或final修饰的在基本类型变量在运行时常量区。

12.static 与 final 修饰的引用变量的对象在哪里？
final 修饰的是常量，值/对象不可变，内存地址同样不可变；所以 final 修饰的对象在常量池中或在堆的老年代中。
static 修饰的是类变量/静态变量，值/对象可变，逻辑上在方法区中，物理上在堆中。

final LayoutParams lp = (LayoutParams) child.getLayoutParams();

可用以下参数调整：
-Xms:堆的初始内存分配，最小值；
-Xmx:堆被分配的最大值；-Xmx256m
-Xmn:新生代的大小；
-XX:NewSize:新生代最小值；
-XX:MaxNewSize:新生代最大值；

13.直接内存
不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；
如果使用了NIO，这块区域会被频繁调用，在java堆内可以用DirectByteBuffer对象直接引用并操作；
这块内存不受java堆大小的限制，但受本机总内存的限制，可以通过
-XX:MaxDirectMemorySize
来设置（默认和堆内存最大值一样），所以也会出现OOM异常。
因为默认和堆内存一样大，所以在一个应用程序占满机器内存的情况下，直接内存其实是侵占了一半的堆内存。

14.堆和栈区别
1）功能方面；
栈以栈帧的方式存储方法调用的过程，并存储方法调用过程中 基本数据类型的变量 以及 对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放。
堆内存用来存储Java中的对象与数组，无论是成员引用变量、局部引用变量、还是类引用变量（静态引用变量），他们指向的对象都存储在堆内存中。（所以静态变量的对象存储在堆内存中的。）
2）线程独享还是共享；
栈内存是线程私有的，其存储的变量只有当前线程可见。
堆内存对所有线程可见。堆内存中的对象可以被所有线程访问。当然必须有指向传入，没有指向传入，新起的线程，怎么知道已有对象的地址。
3）空间大小；
栈内存要远远小于堆内存，所以栈的深度是有限制的，会发生栈溢出 StackOverFlowError
堆内存会抛出 OutOfMemoryError

15.栈溢出 StackOverflowError，Hotspot 中栈的大小是固定的，不支持拓展。
递归：由于一个方法循环调用自身，所以已经入栈的方法直到最后一次递归返回才会依次出栈，这期间可能会因为过多栈帧的入栈而造成 StackOverFlowError。
循环：只是在一个方法内，不过在循环内不要新建引用，应该放在循环之外。新建的引用也会入栈和出栈，频繁创建，就会频繁入栈出栈，影响效率。

16.OutOfMemoryError 堆溢出，两种情况
1）内存溢出：申请内存超出了最大堆内存的空间
2）内存泄漏：内存空间过于碎片化，虽然总空间还很大，但是局部空间不足以容纳新创建的对象。

17.方法区也会溢出！
1）运行时常量池溢出
2）方法区中保存的 class 对象太多，没有被即时回收掉或者 class 信息占用的内存超过了我们的配置。
Class被回收很困难，暂时当成不能回收吧。

18.StackOverFlowError 与 OutOfMemoryError，分别代表什么，有什么区别，职责是什么？
1）一个是栈溢出，一个是堆溢出。
2）栈解决了程序的运行问题，即程序如何执行，如何处理数据的问题。
堆解决的是数据存储的问题，即数据是怎样放，放在哪里。
3）栈负责的是运算逻辑。
堆负责的是存储逻辑。

19.虚拟机优化技术
1）编译优化技术--方法内联：把两个方法合并。把目标方法里的代码复制到调用方法的位置，相当于取消了一次栈帧的创建。一般都是简短的方法。
2）栈的优化技术——栈帧之间数据的共享：上层栈帧可以复用下层栈帧的数据。上层栈帧一般都是从下层栈帧跳过来的，空间共用，省去了数据的传递。

第三节 虚拟机中的堆内存
01.对象的分配：在虚拟机遇到一条 new 指令时的操作过程
1）检查加载：先检查对应的类的class类信息是否存在，不存在还需要通过classloader加载class类信息，
2）分配内存：有两种情况：指针碰撞，空闲列表
3）内存空间初始化：内存分配完成后，虚拟机会将分配到的内存空间都初始化为默认值，但在方法（栈帧）内部自己的局部变量需要手动初始化。
基本类型变量是自己的默认值，对象类型是null。
4）设置：虚拟机对对象进行必要的设置，如对象是哪个类的实例，如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息都放在对象头中。
5）对象初始化：在完成上面的步骤后，一个对象在虚拟机角度就算创建完成了，接下来就是按照程序猿的设定进行定制化操作（也就是构造器里的参数赋值），这样才算完全创建成功。

02.分配内存的操作过程
1）指针碰撞：如果堆内存是绝对规整的，用过的内存都放在一边，空闲在另一边，那中间就是指针，此时分配内存就是把指针向空闲区域移动一段与对象内存大小相等的距离，这种分配方式称为指针碰撞。
一般在程序刚启动，没有发生第一次GC时，是这种分配方式。GC后看执行的是哪种垃圾收集器。
2）空闲列表：堆内存不规整，已使用的和空闲的相互交替，就不能用指针碰撞，虚拟机必须维护一个列表，记录可用内存块，在分配时从中选择足够大的空间分给对象实例，并更新列表记录，这种称为空闲列表。
内存溢出就是因为空闲列表记录的内存块是分隔开的，当其中最大的内存块都不足以容下对象时，就会OOM。一般发生在对象的频繁创建与回收的时候。
选择哪种分配方式由Java堆内存是否规整决定，而堆内存是否规整由所采用的垃圾收集器是否带有压缩整理功能决定。但这两种情况在分配内存时都会有并发问题：并发安全：

03.内存分配过程中的安全问题？
1）CAS 机制（compare And Swap 比较与交换，乐观锁）：搭配 volatile 使用，对分配内存控件的动作进行同步处理。
2）本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）
每个线程在初始化时，在堆内存中申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个 Buffer（缓冲区）。当 Buffer 不足时，再重新从 Eden 区域申请一块继续用。这样就不存在竞争，可以提高效率。
TLAB 可以让每个线程拥有自己的专属指针来分配空间，减少了同步开销。但对象所在空间其他线程也是可以访问的，只是无法分配而已。

可以通过参数：-XX:+/-UseTLAB 启动和禁用

04.对象的内存结构布局
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）、对其填充（Padding）。
因为一条数据还包含对象头和尾部填充，所以实际占用空间会略大，大概1:1.5
1）对象头包括两部分信息，数组还有第三部分
第一部分用于存储对象自身的运行时数据（mark Word），如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳，对象地址（引用变量里保存的就是这个地址）等、
第二部分是类型指针 classPoint（对象在方法区的类信息），即对象指向它的类元数据的指针。虚拟机通过这个指针来确定这个对象是哪个类的实例。
第三部分：为 数组 记录数组长度的数据。
2）实例数据：代码中所定义的各种类型的字段内容。
3）对其填充：起着占位符的作用，这是由于HotSpot VM的自动内存管理系统要求对象的大小必须是8字节的整数倍。不足时，就需要对其填充来补齐。

05.栈上的引用变量是如何访问堆内存中的具体对象的？
目前主流方式有两种 句柄 和 直接指针；
1）句柄：在堆内存中会划分出一块内存来作为句柄池，Reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
结构图：引用变量 -> 句柄 -> 对象
2）直接指针：Reference中存储的直接就是对象地址。在HotSpot上使用的是直接指针。
结构图：引用变量 -> 对象

06.句柄和直接指针的优缺点？
句柄最大的好处是 引用变量 中存储的是稳定的句柄地址，因为在对象被移动（垃圾回收时移动对象是非常普遍的）时只会改变句柄中的实例数据指针，Reference本身不需要改变。但是因为有一层中转，访问速度肯定有所下降。
直接指针最大的好处是速度更快，它节省了一次指针定位的时间开销，在频繁的访问中，省下的时间也是很可观的。

07.对象的内存地址在GC整理内存后会改变吗？会改变。
1）栈中的引用是GC Roots的一部分。
2）Object地址改动的时候会在原对象的表头（Mark Word）中保存移动后的对象地址（通过Mark Word中的forwarding pointer字段）。
3）将栈中引用地址改为新对象的地址。通过原对象中的forwading pointer来改正引用。
4）回收掉Old Object所在的内存。

08.逃逸分析：判断对象的作用域是否会逃逸出方法体，默认启动。同样的对象只会分配一个，在本地线程缓冲区里。
逃逸可分为不逃逸，方法逃逸，线程逃逸，JVM都有相对应的优化。
1）虚拟机提供的一种优化技术，基本思想是对于线程私有的对象，也就是方法（栈帧）中创建的对象，将它们打散分配在栈上，而不是分配在堆上。好处是对象跟着方法调用自行销毁，不需要进行垃圾回收，可以提高性能。
2）栈上分配需要的技术基础，逃逸分析。
3）逃逸分析的目的是判断对象的作用域是否会逃逸出方法体，线程。
4）任何可以在多个线程之间共享的对象，一定都属于逃逸对象。
5）方法内创建的对象，作用域只在方法内，没有让外部引用持有的对象，就是为逃逸对象，就可以在栈上分配。

栈上分配的相关参数：
-server JVM运行的模式之一，server模式才能进行逃逸分析，JVM运行模式还有mix/client
对栈上分配发生影响的参数就这三个-server ;
1）-XX:+DoEscapeAnalysis：启用逃逸分析（默认打开）
2）-XX:+EliminateAllocations：标量替换（默认打开）
3）-XX:+UseTLAB：本地线程分配缓冲（默认打开）
4）-Xmx10m 和 -Xms10m：堆的最大，最小值
5）-XX:+PrintGC：打印GC日志（默认关闭）
-XX:+（打开）-（关闭）

09.GC 如何判断对象的存活的？
1）引用计数法：快，方便，实现简单，缺点：对象相互引用时，很难判断对象是否该回收，需要引入额外的机制来处理，影响效率。Python在使用。
2）可达性分析：GC Roots，通过一系列被成为 GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索过的路径称为引用链（Reference Chain），当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。

10.GCRoots包括：
1）虚拟机栈帧中引用的对象：栈帧回收后就会移除gc root区域。（实际代码中用的主要就是这个）
2）方法区中类静态属性引用的对象（还算常用）
3）方法区中常量引用的对象
4）本地方法栈中 JNI 引用的对象
5）JVM 内部引用（class 对象、异常 NullPointException、OutOfMemoryError，系统类加载器）
6）所有被同步锁持有的对象
7）JVM 内部的JMXBean、JVMTI 中注册的回调、本地代码缓存等
8）JVM 实现中的 "临时性" 对象，跨代引用的对象（在使用分代模型回收只回收部分代时）

AndroidStudio内置的内存分析软件 Monitor
在对象中重写 finalize() 方法中可以拯救一下，不过看运气，这个方法执行缓慢，通常都救不了。

11.引用方式有几种？四种。
1）强引用：直接用等号（=）赋值的引用方式。
2）软引用：SoftReference 包装的引用，内存不足时，就会被回收；通常会结合ReferenceQueue（引用队列）来使用，再被内存回收后，会被加载到队列中。
通常可用来实现内存敏感的高速缓存，如内存中的图片缓存。
String abc = soft.get(); 相当于强引用
3）弱引用：WeakReference 包装的引用，只能生存到下次GC发生时，也就是GC执行了，就会回收。也会结合ReferenceQueue来使用。
通常用于debug，内存见识工具等程序中。因为这类程序一般要求既要观察到对象，又不能影响该对象正常的GC过程。
在WeakHashMap、ThreadLocal中有使用。
4）虚引用：PhantomReference 包装，必须与ReferenceQueue联合使用。随时回收，而且他是回收前，就已经被放到关联队列中了。所以虚引用也被称为幽灵引用。
可以用于检测垃圾回收器是否处于存活状态。

12.弱引用应用场景？
1）如果一个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么应该用 Weak Reference 来记住此对象。
2）想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候就应该用弱引用，这个引用不会在对象的垃圾回收判断中产生任何附加的影响。


第四节 堆内存的回收以及回收算法
jps -v 看所有的配置
参数配置
1）-Xms:堆的初始内存分配，最小值；
2）-Xmx:堆被分配的最大值；-Xmx256m
3）-Xmn:新生代的大小；
4）-XX:NewSize:新生代最小值；
5）-XX:MaxNewSize:新生代最大值；
6）-XX:+PrintGC：打印GC日志（默认关闭）
7）-XX:+PrintGCDetails：打印GC日志（默认关闭）
8）-XX:+HeapDumpOnOutOfMemoryError：当堆内存控件移除时输出堆的内存快照
9）-XX:SurvivorRatio=8 表示Eden和Survivor的比值，缺省为8，Eden：From：To=8：1：1

01.回收机制主要发生在哪里？堆中。
java与C++等语言最大的技术区别：自动化的垃圾回收机制（GC）Garbage Collection
栈：栈的生命周期是跟随线程的，而且一般也不大，所以不需要关注。
堆：堆中的对象是垃圾回收的重点。
方法区（永久代/元空间)：也会发生垃圾回收，不过这块的效率比较低，一般也不需要关注。

02.堆的细分可分为：
1）新生代 PSYoungGen，三种：1份
Eden            8
From Survivor   1
To Survivor     1
2）老年代 ParOldGen：2份

03.GC异常的发生时间与名称，问题集合
1）新生代回收 Minor GC/Young GC
2）老年代回收 Major GC/Old GC，只进行老年代的回收，目前只有CMS会有这个单独操作。
Major GC定义混乱，有的指老年代，有的指整堆收集。具体场景具体分析
3）整堆收集：FullGc 在新老都回收，有的回收机制也包含方法区（元空间 Metaspace）的回收。
4）GC overhead limit exceeded 超过98%的时间来做GC，并且回收了不到2%的堆内存时，会抛出此异常。
1、垃圾回收会占据资源。
2、回收效率过低也会有限制。

04.堆内存分配策略
1）对象优先在Eden上分配，如果 Eden 不足就会发生 Minor GC（内存没沾满的时候） 。
2）大对象直接进入老年代，大对象：需要大量连续内存空间的Java对象，比如很长的字符串和大型数组。比新生代剩余空间大，那不用说；小的话，看JVM的参数配置了，缺省是0。
1、导致内存有空间，还是需要提前进行垃圾回收获取空间来释放他们。
2、会进行大量的内存复制。
大对象的参数设置： -XX:PretenureSizeThreshold 参数，大于这个数量直接在老年代分配，缺省为0，表示绝不会直接分配在老年代。
3）长期存活的对象将进入老年代：默认15岁，-XX:MaxTenuringThreshold 调整
4）动态对象年龄判断：在Survivor空间中，相同年龄的所有对象的总和大于Survivor空间的一半，大于等于此年龄的对象直接进入老年代，就算才一岁，也不行。
5）空间分配担保：新生代中有大量的对象存活，Survivor空间不够，MinorGC后仍然存活，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。
无法担保，根据设置的不同会进行 MinorGC ，或者FullGC。

05.复制算法：（新生代中使用）
说明：将内存按容量分为大小相等的两块。每次使用一块，但这一块用完，就将不能回收的对象顺序复制到另一块上，然后把已使用的清理掉。
特点：由于每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等情况，按顺序分配即可，实现简单，运行高效。但是这种算法的代价是利用率只有一半，另一半作为下一次的复制区域。

知识扩展：
专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一快较大的 Eden 空间两块较小的 Survivor 空间，每次使用 Eden 和一块 Survivor 。
当回收时，将 Eden 和 Survivor 中还存活的对象全部复制到另一块 Survivor 上，然后清理 Eden 与已用的Survivor。
HotSpot虚拟机默认 Eden 与 Survivor 的大小比例是8:1:1，所以新生代中可用内存空间为整个新生代的90%（80+10），浪费10%。
当回收的对象内存大于10%时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion）

06.标记-清除算法（Mark-Sweep）
1）标记：标记出所有需要回收的对象。
2）清除：在标记完成后统一回收所有被标记的对象。
主要缺点是内存碎片问题，标记清除后会产生大量不连续的内存碎片，这会造成之后分配较大对象时，找不到足够连续内存，要么触发提前下一次GC，要么就会OOM。

07.标记-整理算法（Mark-Compact）
标记出所有需要回收的对象。在标记完成后，让所有可存活的对象统一移动到一端，然后直接清理掉边界以外的内存。

08.堆内存中的垃圾回收器有哪些
新生代中因为每次垃圾回收时，都会有大量对象死去，所以一般使用复制算法。
老年代中因为存活率高，没有额外空间对他进行分配担保，就必须使用 标记-清除 或者 标记-整理 算法来回收。
1）单线程中  serial 对应 SerialOld 也可以用 CMS
2）多线程中  ParNew 对应 SerialOld 也可以用 CMS
3）多线程中  Parallel Scavenge  对应 SerialOld 也可以用 Parallel Old
4) JDK 1.7 后引入了G1.
G1 跨新生代和老年代；标记整理+化整为零。 并行与并发收集器。
1.7后正式引入，采用分区回收的思维，基本不牺牲吞吐量的前提下完成低停顿的内存回收；可预测的停顿是其最大的优势。
面向服务端应用的垃圾回收器，目标为取代CMS.

第五节 堆内存的回收策略
并行：垃圾收集的多线程同时运行。
并发：垃圾收集的多线程和应用的多线程同时进行。
吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）
垃圾收集时间=垃圾回收频率 * 单次垃圾回收时间

01.Serial/Serial Old： 最古老的，单线程，独占式，成熟，适合单CPU 服务器，所以这东西要被淘汰了。
-XX:+UseSerialGC 新生代和老年代都用串行收集器。

02.ParNew： 和Serial 基本没区别，唯一的区别：多线程，多CPU的，停顿时间比 Serial 少。
-XX:+UseParNewGC   新生代用ParNew，老年代用Serial Old

03.Parallel Scavenge (ParallerGc)/Parallel Old：关注吞吐量的垃圾收集器，主要适用于在后台运算而不需要太多交互的任务。
-XX:+UseParallerGC 新生代用ParallelGC，老年代使用Serial Old

04.Concurrent Mark Sweep（CMS）：基于标记-清除；是一种以获取最短回收停顿时间为目标的收集器。
目前很大一部分的java应用在用，像互联网或者B/S系统服务端上，这类服务器尤其重视服务的响应速度。
四个步骤：标记时会暂停用户线程
1)初始标记-短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。
2)并发标记-和用户的应用程序同时进行，进行GC RootsTracing的过程。
3)重新标记-短暂，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的哪一部风对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，单元比并发标记的时间短。
4)并发清除-同时进行。

由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以和用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。
-XX:+UseConcMarkSweepGC 表示新生代使用ParNew ，老年代使用CMS

05.CMS的缺点：会产生浮动垃圾。
由于CMS并发清理阶段用户线程还在运行着，伴随着程序运行自然就会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理他们，只好留待下一次GC时在清理掉。这一部分就称为 浮动垃圾。
同时由于CMS是标记-清除方式，没有整理内存，所以在频繁回收内存的时候会造成大量的内存碎片，在分配大对象空间不足时，就会进行内存碎片整理，这里一般会使用Serial Old 来整理，但他是单线程的，整理的空间太大就会很卡。

06.G1：适用于大内存，6-8G以内推荐CMS，以上用G1
G1不在只分新老两个区，而是分为多个 Region（区域块），每个区域块可以是 Eden，Survivor，Old，Humongous 四种，相互之间也可以互相转换。但也同样因为这样，大内存才能发挥 G1 的优势。
Humongous 是用来存储大对象的，一般大于一个Region容量的就是大对象，可以多个连续的Humongous区域来存储。
清理步骤分为以下几步：
初始标记，新生代GC：并行，swt
并发标记：并发
最终标记：并行，swt
独占清理：并行，swt

07.G1的优点
1）并发与并行：G1能充分利用多CPU、多核环境下的硬件优势，使用多核CPU 来缩短Stop-The-World停顿时间，部分其他收集器原本需要停顿Java线程执行的GC操作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
2）分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但他能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的就对象以获取更好的收集效果。
3）空间整合：从整体看多个区域块是标记整理，从局部看：两个 Region 之间可以基于复制算法实。G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存，不会因为大对象分配时无法找到连续内存空间而引发 GC 或者 OOM。

参数设置：
-XX:UseG1GC：启动G1收集
-XX:G1HeapRegionSize=size 来设置 Region 的大小
-XX:MaxGCPauseMillis 指定目标的最大停顿时间，G1尝试调整新生代和老年代的比例，堆大小，晋升年龄来达到这个目标时间。
-XX:ParallerGCThreads 设置GC的工作线程数量。

08.Stop The World 现象
GC收集器造成业务线程暂停的现象就是stw
GC收集器的目标就是尽可能的减少STW的时间和次数。

09.ZGC垃圾回收机制，把STW的情况控制在仅有一次，
关键技术：
1.有色指针（Colored Pointers）
2.加载屏障（Load Barrier）


第七章 热修复 ClassLoader 机制
01.什么是基于栈的虚拟机？
对于基于栈的虚拟机来说，每一个运行的线程，都有一个独立的栈。栈中记录了方法调用的历史，每一次方法调用，栈中都会多一个栈帧，最顶部的栈帧称作当前栈帧，代表当前执行的方法。
基于栈的虚拟机通过操作数栈进行所有操作。

02.基于寄存器的虚拟机
基于寄存器的虚拟机中没有操作数栈，但有很多虚拟寄存器，和操作数栈相同，这些寄存器也存放在运行时的栈中，本质上就是一个数组。与JVM相似，在dalvik VM中每个线程都有自己的调用栈，方法调用的活动记录以帧为单位保存在调用栈上。
与JVM相比，可以发现 Dalvik程序的指令书明显减少了，数据移动次数也明显减少了。

03.什么是Dalvik？
Dalvik 是Google公司自己设计用于Android平台的java虚拟机。支持已转换为.dex(Dalvik Executable)格式的Java应用程序的运行。
.dex 格式是专为Dalvik应用设计的一种压缩格式，是很多.class 文件压缩后的产物，适合内存和处理器速度有限的系统。

04.什么是ART？
Android Runtime 用来替换Dalvik的虚拟机，4.4中引入的一个ART运行时，5.0以后的就都是ART虚拟机。
在应用安装的时候Ahead-Of-Time(AOT)预编译字节码到机器语言，这一机制叫Ahead-Of-Time(AOT)预编译。
应用程序安装会变慢（确实很慢），但是执行将更有效率，启动更快。

05.Android N 开始混合使用 AOT 编译，解释执行 和 JIT。
1）最初安装不进行AOT编译（安装变快了），运行过程中，解释执行，对经常执行的方法进行JIT，经过 JIT  编译的方法将会记录到 Profile 配置文件中。
2）当设备闲置和充电时，编译守护进程会运行，根据 Profile 文件对常用代码进行 AOT  编译。待下次运行使用。

06.Dalvik与ART的优缺点？
1）Dalvik是在4.4之前使用的虚拟机，ART是5.0之后使用的虚拟机。
2）在语言编译方面：
在Dalvik上，应用启动运行时需要解释运行，常用的热点代码通过即时编译器（JIT）将字节码转换为机器码，运行效率低。
在ART上，应用安装时，字节码预编译（AOT）成机器码，安装慢了，但启动快了。运行效率高。
3）ART占用的空间比Dalvik大（字节码变为机器码，怪不得那些个App下载的时候那么小，安装后那么大）空间换时间
4）AOT也可以明显改善电池续航，因为程序不用每次运行时重复编译了，从而减少CPU使用频率，降低了电耗。

07. .dex files 与 .oat files
1）dexopt：加载 dex 文件时，对 dex 文件进行验证和优化，转化为 odex（Optimized dex）文件，Dalvik上运行的就是odex文件。
2）dex2oat：在安装时对dex文件进行 AOT 预编译操作，编译为 OAT 可执行文件（ELF File 机器码）。

08.ClassLoader Java类加载器
1）BootClassLoader：用于加载Android Framework层class文件，例如Activity.class类。
2）PathClassLoader：用于App的类加载器，也就是自己写的类，只要不是framework层的都是，Googlejar类的也是这个加载器加载的。
3）DexClassLoader：加载指定的dex，以及jar、zip、apk中的classes.dex 文件，除了有个构造和PathClassLoader不一样以外，其他一样。
optimizedDirectory 是优化后的 odex 文件的输出目录，DexClassLoader 可以自定义，PathClassLoader 是默认的，/data/dalvik-cache

09.双亲委托机制
某个类加载器在加载类时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；不能或没有父类，就自己加载。
父类加载器不是当前加载器的继承的父类，而是调用构造方法时传入的上级类加载器。

10.热修复：尼玛原来这么简单的啊。
利用的就是反射获取ClassLoader，把指定的 dex 文件插入 DexPathList 中，必须插在有问题的dex之前。类信息是按顺序加载的，且只会获取一次，就算有重名的，也不会再加载。
gradle开发：插桩+自动生成Dex。


第八章 Kotlin
https://www.jianshu.com/u/a324daa6fa19
@JvmOverloads 多个构造函数与多个方法的重载

第一节 kotlin 关键字

01.访问限制类修饰符：6个，默认都是 final 修饰的，不可继承
1）public：属性和方法对所有类可见，默认
2）protected：自身及子类可见，继承需要配合 open 使用。这里与 Java 不同，Java 同包可见
3）internal：当前模块内可见
4）private：私有的，仅自己可见
5）inner：定义内部嵌套类，私有的尽自己可见，允许在嵌套类中引用外部类实例。
6) sealed 密封类，不可继承，内部搭配 object 关键字，外部配合when来使用，整个一枚举类的翻版，到底有啥用。

02.非访问限制类修饰符：5个
1）final：禁止成员覆盖；类，方法默认已加上此关键字。
2）open：让类可继承，要重写方法，那方法前也得加上open
3）const：将属性标记为编译期常量，等同于final，只能定义基本变量和 String 类
4）abstract：抽象类或方法的修饰符，自带open
5）override：将一个成员标记为对超类成员的覆盖

03.定义类，接口，枚举，单例，伴生类，数据类符：6个
1）class 声明类
2）interface：自带open
3）enum class：枚举类
4）object：同时声明一个类及其实例，相当于单例
object : 声明匿名内部类
5）companion object：伴生对象（工厂方法，静态成员）
6）data class：数据类（自动生成方法的实现类）

04.调用自身与父类符：2个
1）this：调自身
2）super：调父类

05.对比符：1个
is 等价于Java中的 instanceOf
!is 判断一个值不是指定类型
可用于when中

06.变量声明：2个
1）val：赋值后不可变，相当于final修饰，set不可用。
2）var：可变
get/set自动生成，也可自定义
get
    声明属性的 getter
    用作注解使用处目标
set
    声明属性的 setter
    用作注解使用处目标

07.中断符：2个
1）break 中断当前代码块
2）continue 中断一次执行

08.判断符：4个
1）if..else..：两个关键字都出现的时候，最后一行可以有返回值。
2）when 分支表达式；相当于switch..case
3）in 中缀符，判断值是否属于一个区间，集合，相当于 contains 方法
指定在for循环中迭代的对象
when 中亦可
逆变：等同于泛型的 super

!in 判断值是否不属于一个区间，集合，相当于 contains 方法
when 中范围判断

09.循环符：3个
1）for
2）while
3）do{}while

10.区间符：3个
1）..：闭区间（包含两端）
2）until：递增，半闭半开区间
3）downTo：递减，闭区间
4）step：设置步长
开区间就是两端不包含。

11.转换符：1个
as 类型强转；为 import 指定别名（有啥用）
as? 用于安全类型转换

12.默认方法块：2个
1）constructor 声明一个主构造函数或次构造函数
2）init{} 初始化语句块，

13.异常捕获符：4个
1）try{}catch(){}finally
2）throw 抛出一个异常

14.默认的常规标识符：2个，
field 用在属性访问器内部来引用该属性的幕后字段，get/set 中
it 用在 lambda 表达式内部来隐式引用其参数

15.泛型符：3个
1）out：将类型参数标记为协变，相当于 extends。
2）in：将类型参数标记为逆变，相当于 super。
3）where 指定泛型的多个约束，定义类、接口时使用。

16.其他：9个
package 指定当前文件的包
import 导入声明
fun 函数/方法声明符
return 从最近层的函数或匿名函数返回
vararg 可变参数，参数数组
lateinit 延迟初始化，使用前必须赋值。
typealias 声明一个类型别名
typeof 保留以供未来使用
operator 重载符号，将一个函数标记为重载一个操作符或者实现一个约定

to 中缀调用，infix修饰函数，允许使用中缀符号
Nothing 这个函数永不返回
软关键字：以下符号在适用的上下文中充当关键字，而在其他上下文中可用作标识符：
by：委托
    将接口的实现委托给另一个对象
    将属性访问器的实现委托给另一个对象
by lazy{} 延迟初始化
delegate 用作注解使用处目标
dynamic 引用一个 Kotlin/JS 代码中的动态类型
field 用作注解使用处目标
file 用作注解使用处目标
param 用作注解使用处目标
property 用作注解使用处目标
receiver用作注解使用处目标
setparam 用作注解使用处目标

修饰符关键字：以下符号作为声明中修饰符列表中的关键字，并可用作其他上下文中的标识符：
actual 表示多平台项目中的一个平台相关实现
annotation 声明一个注解类
crossinline 禁止传递给内联函数的 lambda 中的非局部返回
expect 将一个声明标记为平台相关，并期待在平台模块中实现。
external 将一个声明标记为不是在 Kotlin 中实现（通过 JNI 访问或者在 JavaScript 中实现）
infix 允许以中缀表示法调用函数
inline 告诉编译器在调用处内联传给它的函数和 lambda 表达式，作用：消除 lambda 带来的运行开销
reified 将内联函数的类型参数标记为在运行时可访问，具体化，使用inline来修饰函数，reified来修饰类型形参，作用：可以在运行时引用实际的类型参数
noinline 关闭传给内联函数的 lambda 表达式的内联
suspend 将一个函数或 lambda 表达式标记为挂起式（可用做协程）
tailrec 将一个函数标记为尾递归（允许编译器将递归替换为迭代）

第二节 Kotlin 支持以下操作符和特殊符号：
01.需要区别的操作符
1）* 也用于将数组传递给 vararg 参数
2）==、 != —— 相等操作符（对于非原生类型会翻译为调用 equals()）
3）===、 !== —— 引用相等操作符，这个才相当于 Java 中的
4）<、 >、 <=、 >= —— 比较操作符（对于非原生类型会翻译为调用 compareTo()）
5）[、 ] —— 索引访问操作符（会翻译为调用 get 与 set）
6）!! 断言一个表达式非空
7）?. 执行安全调用（如果接收者非空，就调用一个方法或访问一个属性）
8）?: 如果左侧的值为空，就取右侧的值（elvis 操作符）
9）:: 创建一个成员引用或者一个类引用（Person::age）::class.java
10）.. 创建一个区间
11）: 分隔声明中的名称与类型，继承（实现）、函数返回值类型
12）? 将类型标记为可空
13）$ 在字符串模版中引用变量或者表达式：${} 字符串模板
14）->
    分隔 lambda 表达式的参数与主体
    分隔在函数类型中的参数类型与返回类型声明
    分隔 when 表达式分支的条件与代码体
15）@
    引入一个注解
    引入或引用一个循环标签
    引入或引用一个 lambda 表达式标签
    引用一个来自外部作用域的 “this”表达式
    引用一个外部超类

02.一些有用的方法
1）toList 把序列转换成集合
2）apply apply始终会返回作为实参传递给它的对象（返回接收者的对象），返回第一个参数
3）let函数 ?.let{} 非空调用
4）with(params){} with的返回值是lambda中最后一个表达式
5）rangeTo 创建区间 ..
6）maxBy{} 指定比较哪个值找到最大元素，需要一个参数：一个函数
7）filter 过滤（从集合中找寻满足条件的所有元素）
8）map 转换（对集合中的每一个元素应用给定的函数并把结果收集到一个新集合）
9）all 判断集合中的所有元素是否满足某个条件 返回布尔值类型
10）any 判断集合中是否至少有一个元素满足条件 返回布尔值类型
11）count 返回集合中满足条件的个数
12）find 找到集合中第一个满足条件的元素，如果没有返回Null 等价于 firstOrNull
13）groupBy 根据条件把集合转换成分组的map
14）flatMap 根据作为实参给定的函数对集合中的每个元素做变换，然后把多个列表合并成一个列表
15）asSequence() 把任意的集合转换成序列 （惰性操作）


第九章 自定义UI
第一节 View的相关知识
01.View的视图结构
1）Activity 内包含一个 PhoneWindow（窗口），内含一个 DecorView（继承自FrameLayout），内部是一个LinearLayout，包含上下两部分，上部是标题栏（看主题设置），下部就是content，id就是content，这也是 setContentView() 方法的由来。
2）PhoneWindow 负责管理界面显示以及事件响应，是Activity 与 View 树交互的接口。
3）ViewRoot 在 Activity 启动时创建，负责管理、布局、渲染窗口UI等。

02.ViewRoot是干什么的？
ViewRoot 是View树的管理者，负责将 DecorView 与 PhoneWindow 链接起来，并控制 View 树的绘制流程
每个DecorView 都有一个 ViewRoot 与之关联，这种关联由 WindowManager 负责管理。

03.View的添加与绘制流程流程
1）WMG(WindowManager).addView
-> ViewRootImpl.setView
-> ViewRootImpl.requestLayout
-> ViewRootImpl.scheduleTraversals
-> TraversalRunnable.run
-> ViewRootImpl.doTraversal
-> ViewRootImpl.performTraversals
2）performTraversals()之后View 开始绘制
mesure -> layout -> draw
三个环节中还需要判断是否需要计算，因为有隐藏状态，以及再次请求重新分配布局的方法：requeLayout()

04.measure、layout、draw 的代码流程图。
1）View.requestLayout
-> ViewRootImpl.requestLayout
-> ViewRootImpl.scheduleTraversals
-> (getRootMeasureSpes)
-> ViewRootImpl.perforMeasure
-> View.measure
-> DecorView.onMeasure
-> FrameLayout.onMeasure
-> RamenLayout.measureChildWithMargins
-> ViewGroup.getChildMeasureSpec
-> View.measure
-> LinearLayout.onMeasure
-> LinearLayout.measureVertical
-> 子View.measure
2）ViewRootImpl.performLayout
-> (DecorView)View.Layout
-> View.setFrame(会调用 invalidate)
-> Decorview.onLayout
-> FramenLayout.onLayout
-> FrameLayout.layoutChildren
-> LinearLayout.onLayout
-> LinearLayout.LayoutVertical
-> View.layout
-> View.onLayout（一般不需要实现）
3）View.invalidate
-> ViewinvalidateInternal
-> ViewGroup.invalidateChild
-> ViewGroup.invalidateChildinParent
-> ViewRootImpl.invalidateChildInParent
-> ViewRootImpl.scheduleTraversals
-> ViewRootImpl.PerformTraversals
-> ViewRootImpl.performDraw
-> ViewRootImpl.DrawSoftWare
-> View.draw
-> View.drawBackground
-> View.onDraw
-> view.dispatchDraw
-> View.onDrawForeground
-> Viewgroup.dispatchDraw
-> ViewGroup.drawChild
-> View.draw

05.View的四个函数
1）一个参数，是Java代码里直接调用的，默认会调用两个参数的，有些会直接调用父类的一个参数
2）两个参数是在xml里定义调用的。
3）三个参数，设置Style使用。
4）四个参数，API 21之后添加的，也是设置style用的，应该涉及到 Android 版本问题。

06.view的基础知识：屏幕的坐标原点是左上角，向右X轴正方向，向下Y轴正方向
1）getLeft()：属性：mLeft，View左边到父布局的左边的距离。
2）getRight()：属性：mRight，View右边到父布局左边的距离。
3）getTop()：属性：mTop，View上边到父布局顶边的距离。
4）getBottom()：属性：mBottom，View下边到父布局顶边的距离。
5）getX()是 mLeft + getTranslationX()
6）getY()是 mTop + getTranslationY()
7）onDraw()：
绘制背景：background.draw(canvas)
绘制自己：onDraw()
绘制children：dispatchDraw()
绘制装饰：onDrawScrollBars()

07.View相关知识
1）requestDisallowInterceptTouchEvent(boolean)强制请求分发触摸事件。
2）TouchSlop：最小滑动距离，获取方法：ViewConfiguration.get(this).scaledTouchSlop，zoom中有使用
3）VelocityTracker：速度跟踪器，只在move中有用，up抬起时为0
4）GestureDetector：手势检测，相关方法：单击，拖动，滑动，长按，双击。
5）Scroller（待深入研究）：弹性滑动对象，与view中的computeScroll方法配合。
6）View 的 OnTouchListener 优先于 onTouchEvent，返回 true，onTouchEvent不会执行，up事件不执行的话，平常调用的点击事件 onClickListener 也不会执行。
7）view滑动：
scrollTo/scrollBy：操作简单，适合对View内容的滑动；
动画：操作简单，主要适用于实现复杂的动画效果；
改变布局参数，操作稍微复杂，适用于有交互的View。

08.activity 中获取 View 的宽高：
1）onWindowFocusChanged()：
2）view.post(runnable)
3）viewTreeObserver.addOnGlobalLayoutListener()
4）view.onSizeChanged()：view的宽高变化后，会调用此方法。

09.自定义View中比较重要的回调方法：
第一次进入时的顺序回调
1）onFinishInflate()：从XML加载组件完成后回调；
2）onAttachedToWindow()：组件放入窗口时回调
3）onWindowVisibilityChanged(int)：当包含该组件的窗口可见性发生改变时回调
4）onMeasure()：测量view宽高
EXACTLY 精确值模式，具体数字如100dp或match_parent，默认即为EXACTLY；
AT_MOST 自适应模式，warp_content,需要用setMeasureDimension(w,h)设置算好的宽高；
UNSPECIFIED，想要多大即多大，所以可以超过屏幕尺寸，显示不下的在屏幕之外；用于系统内部，目前没用过。
5）onSizeChanged()：组件大小改变时回调；
6）onLayout()：控制内部子控件显示的位置
7）onDraw()：绘制所需要显示的内容
8）onWindowFocusChanged()：当包含该组件的窗口失去或得到焦点时回调
退出时的顺序回调onWindowVisibilityChanged->onWindowFocusChanged->onDetachedFromWindow

非顺序回调：
9）onTouchEvent()：触摸事件，不消费ACTION_DOWN的话，之后的也不会消费，消费的话down，move，up，统一消费。
10）onFocusChanged()：当该组件焦点发生改变时回调
11）onKeyDown()：键盘键按下
12）onKeyUp()：键盘键按下后后抬起
13）onTrackballEvent()：发生轨迹球事件时回调
14）onDetachedFromWindow()：组件从窗口移除时回调

10.Canvas方法：
1）translate(x,y)：将原点(0,0)移动(x,y)
2）rotate(a,x,y)：将画布以(x,y)为中心旋转a度
2）scale(x,y,px,py)：将画布缩放
2）skew(x,y)：将画布倾斜
3）save(),saveLayer(),saveLayerAlpha():保存画布当前状态，并返回int值，方便移除此状态
4）restore():返回画布此次保存的初始状态
5）restoreToCount():移除画布此次保存的状态

11.ViewTreeObserver：
1）OnWindowFocusChangeListener：window的焦点状态发生改变时,（view已注册）
2）OnWindowAttachListener：当View树绑定到window上的时候回调用，（view已注册）
3）OnGlobalFocusChangeListener：当一个视图树的焦点状态改变时，会调用的接口
4）OnTouchModeChangeListener：当视图树的触摸模式发生改变时，会调用的接口
5）OnEnterAnimationCompleteListener：

6）OnGlobalLayoutListener：当视图树的布局发生改变或者View在视图树的可见状态发生改变时会调用的接口
7）OnComputeInternalInsetsListener：
8）OnScrollChangedListener：当视图树的一些组件发生滚动时会调用的接口
9）OnPreDrawListener：当视图树将要被绘制时，会调用的接口
10）OnWindowShownListener：

11）OnDrawListener：视图树绘制时调用

第二节 自定义 View
布局：onMeasure（测量），onLayout（布局）
显示：onDraw（view），canvas、paint、clip、rect、animation、path（贝塞尔）、line、text绘制
交互：onTouchEvent（事件分发），组合的viewgroup

01.自定义View的需要实现基本方法
1）onMeasure()（测量）：测量 View 的宽高
2）onLayout()（布局）：决定 View 在 ViewGroup 中的位置
3）onDraw()（绘制）：绘制 View

自定义 Veiw 需要实现 onMeasure 与 onDraw
自定义 ViewGroup 需要实现 onMeasure 与 onLayout，还可以自定义 LayoutParams，如果继承自 ViewGroup ，需要用到 margin 属性，还需要重写 generateLayoutParams 方法。

02.LayoutParams（布局参数）：width（宽），height（高）
1）MATCH_PARENT 与 FILL_PARENT 的值为 -1，属于 EXACTLY
2）WRAP_CONTENT 的值为 -2，属于 AT_MOAT，
3）具体 DP 值时，则为具体的宽高；属于 EXACTLY
4）每个 ViewGroup 子类都有属于自己的 LayoutParams
5）LinearLayout 等布局的 LayoutParams 都是基于ViewGroup 的 MarginLayoutParams 实现的。
6）ViewPager 与 Galler 是 继承自 LayoutParams

03.MarginLayoutParams 继承自 VG 的 LayoutParams。
1）leftMagin：距左边的距离，layout_marginLeft，layout_marginHorizontal（级别更高）
2）rightMargin：距左边的距离，layout_marginRight，layout_marginHorizontal（级别更高）
3）topMargin：距左边的距离，layout_marginTop，layout_marginVertical（级别更高）
4）bottomMargin：距左边的距离，layout_marginBottom，layout_marginVertical（级别更高）

获取级别问题
layout_margin > layout_marginHorizontal 与 layout_marginVertical > layout_marginLeft（几个）
所以设置了 layout_margin 之后，其他margin设置都会失效的，包括 start 与 end

5）startMargin：距父View左边的距离，为了兼容从右到左的布局，layout_marginStart
6）endMargin：距父View右边的距离，为了兼容从右到左的布局，layout_marginEnd（这俩货不好用，反正我又不出国，没毛用）

04.自定义的 LayoutParams后，自定义的 ViewGroup 内还需要实现以下几个方法。
1）generateLayoutParams(lp) Java代码创建，内部调用lp的构造方法
2）generateLayoutParams(attrs) 内部调用自定义lp的构造方法解析 xml 配置
3）checkLayoutParams(lp) = lp instanceOf LP
4）generateDefaultLayoutParams() 实现默认的lp设置，addView 时用的

05.AttributeSet 自定义的属性设置，xml中配置的属性。
1）通过 <declare-styleable> 为自定义View添加属性。
2）在xml 中为相应的属性声明属性值。
3）在构造函数里获取属性值。
4）将属性值应用到相对应的位置上。
<declare-styleable name="XXX">
<attr name="name" formate="格式"/>
<attr name="name">
<enum name="name" value="value"/>
</attr>
</declare-styleable>

06.自定义属性的解析方式
1）两种方式获取 TypeArray
系统的：
TypeArray typeArray = context.obtainStyledAttributes(attrs, R.styleable.SolarSystem)
另一种：
TypeArray typeArray = context.theme.obtainStyledAttributes(attrs, R.styleable.SolarSystem, defStyleAttr, 0)
2）获取属性：对应的格式有对应的获取方式
int radius = typeArray.getDimensionPixelSize(R.styleable.SolarSystem_radius, radius)
3）获取完成后需要释放
typeArray.recyel()

07.View 与 LayoutParams 通过 ViewGroup.addView() 建立联系
1）addView(view)：内部调用 addView(view，-1)，默认的lp（wrap，warp）
addView(view，index)：默认的lp
addView(view，w，h)：末尾添加，lp是精确值
addView(view，lp)：末尾添加
addView(view，index，lp)：addView的最终归宿，内部会执行三个方法：
requetLayout()：
invalitdate(true)：
addViewInner(v,index,lp,false)：

2）addViewInLayout(v,index,lp,preventRequestLayout)：preventRequestLayout 用于阻止重新请求布局。在手动添加多个View时，这个方法可以节省重新请求布局的时间，加快程序运行，可以在最后一次addView在重新请求布局，当然也可以不用。
addViewInLayout(v,index,lp)：调用四个参数的，与 addView 区别在于 没有执行 invalidate() 方法。

3）addViewInner(v,index,lp,preventRequestLayout)
if (preventRequestLayout) {
child.mLayoutParams = params;
} else {
child.setLayoutParams(params);
}
setLayoutParams() 方法内部会请求requetLayout() 方法。

08.getMeasureWidth 与 getWidth 的区别？
1）getMeasureWidth()在 measure() 过程结束后就可以获取到值；通过setMeasuredDimension() 方法来设置。
2）getWidth() 在 layout() 过程结束后才能获取到，通过 View 的右边距减去左边距的坐标算出来的。
width = mRight - mLeft
height = mBottom - mTop

09.MeasureSpec 宽高的格式与具体的值
32位二进制，高2位表示宽高的格式，低30位表示宽高的值，最大到2的30次方减1
1）MODE_MASK 标记，3的二进制是11，向左移30位得到的，也就是说高2位是11，其他都是0，
2）mode
UNSPECIFIED： 0左移30得到的二进制，高2位为 00 表示  左移多少都是0，系统内部使用
EXACTLY：精确模式， 1左移30得到的二进制，1的二进制 01 ，左移30位，1，在第二位上，match_parent模式 或 具体数值
AT_MOST：自适应模式， 2左移30得到的二进制，2的二进制 10 ，左移30位，1，在第一位上，wrap_content

父类为 EXACTLY 时，子类模式不变。
父类为 AT_MOST 时，子类是具体dp值时才是 EXACTLY ；match_parent 时也会是 AT_MOST

通过 getChildMeasureSpec(spec，padding，childlpwh) 方法来确定子 View 的 Spec（模式与宽高）
此方法在 onMeasure 中调用

3）二进制计算
mode & MODE_MASK 取得是高2位的交集
size & ~MODE_MASK 取得是低30位的交集
两者取并集就是 MeasureSpec
measureSpec & MODE_MASK 取出高2位的数值，就是 mode
measureSpec & ~MODE_MASK 取出低30位的数值，就是宽/高

10.通常自定义View需要考虑那些？
1）padding 是需要算在 View 的宽高里的。
2）margin 不算在 View 的宽高里，但是计算布局时，需要加上。
3）visibleState 设置显示/隐藏
4）Gravity 属性控制在 layout 中的位置。
5）ViewGroup 是否有漏掉最后一个 View

第三节 触摸事件机制 Touch 与 EventMotion
01.触摸事件机制，传递顺序:activity -> window -> view，默认返回false，方法回调有：
1）disPatchTouchEvent(MotionEvent e)（分发事件，一般不用管）
2）onInterceptTouchEvent(MotionEvent e)， ViewGroup独有
3）onTouchEvent(MotionEvent e)
4）MotionEvent中的方法：
GetX()与getY()是视图坐标，相对坐标，返回的是相对于当前view左上角的xy的坐标。
GetRawX()与getRawY()是绝对坐标，返回的是相对于手机屏幕左上角的xy的坐标。
5）触摸按钮时的回调机制：A包B包C
A.disPatch -> A.intercept -> B.disPatch -> B.intercept -> C.disPatch -> C.touch -> B.touch -> A.touch
6）ViewGroup 推荐使用 onInterceptTouchEvent,View 使用 onTouchEvent。
ViewGroup 消费 down 后，再次消费move与up时，会直接跳过此 ViewGroup 的 intercept。

第四节 Paint 画笔
01.Paint的重要属性：TextPaint.getFontMetricsInt()
1）setAntialias()与Paint(Paint.ANTI_ALIAS_FLAG) ：抗锯齿
2）setStrokeWidth(),宽度是从中间开始计算的
3）setARGB(),setAlpha(),setTextSize(),setStyle(),setColor().
4）基准线是baseline
5）top：ascent的最大值，在基线上方，值为负数；
6）ascent：字体在baseline上方被推荐的距离（一些字体制作商需要参考这个），在基线上方，值为负数；
7）descent：字体在是baseline下方被推荐的距离（一些字体制作商需要参考这个），在基线下方，值为正数；
8）bottom：descent的最大值，在基线下方，值为正数；
获取基线baseline：
val metrics = textP.fontMetricsInt//文本的基线数据
val textHeight = metrics.bottom - metrics.top//文本框所占的高度
有背景框的基线计算
val baseline=背景框的中心点Y + textHeight/2 - metrics.bottom;//文字baseline
无背景框的基线计算
val baseline=textHeight - metrics.bottom;//文字baseline
其实就是
val baseline= - metrics.top;//文字baseline

9）getTextBounds(String text, int start, int end, Rect bounds):获取文字宽高
10）measureText(text)：获取文字宽度

11）ColorMatrix
12）PorterDuffXfermode（不好用），
13）Shader，着色器，渲染器：（TileMode三中模式：CLAMP拉伸；REPEAT重复；MIRROR镜像）
BitmapShader：位图
LinearGradient：线性
RadiolGradient：光束
SweepGradient：梯度
ComposeShader：混合
14）PathEffect画线用，结合Path的lineTo来使用
CornerPathEffect：拐角圆滑
DiscretePathEffect：相当于画了一条毛茸茸的线
DashPathEffect：画虚线
PathDashPathEffect：升级的画虚线
ComPosePathEffect与SunPathEffect：组合前几者

第五节 动画
动画类型分为三种：逐帧动画，补间动画，属性动画：
01.逐帧动画（Frame Animation）：AnimationDrawable相对于animation-list

02.补间动画 Animation：位移，缩放，旋转，透明度；可以采用xml的形式也就是逐帧动画，也可以代码实现。
1）TranslateAnimation -> translate
2）ScaleAnimation -> scale
3）RotateAnimation -> ratate
4）AlphaAnimation -> alpha

03.Animator 属性动画：ValueAnimator、ObjectAnimator，AnimatorSet组合，也有相应的xml对应字段，动画属性值：
1）translationX、translationY，增量平移。
2）rotation、rotationX、rotationY 旋转。
3）pivotX、pivotY没看出和rotation有什么区别。
4）scaleX、scaleY 缩放。
5）x、y 最终位置。
6）alpha 透明度，默认为1，表示不透明；0代表完全透明，即不可见。
7）PropertyValuesHolder，ObjectAnimator.ofPropertyValuesHolder()。
8）Value的主要方法：addUpdateListener()。
9）过度动画（Transiton Animation）：属性动画的变种。

04.布局动画：LayoutAnimationController，在MainAdapter中有使用
1）LayoutAnimationController.ORDER_NORMAL：顺序
2）LayoutAnimationController.ORDER_RANDOM：随机
3）LayoutAnimationController.ORDER_REVERSE：反序

05.动画聚合：
1）AnimationSet -> set
2）AnimatorSet的方法；
palyTogether()
playSequentially()
play().with()、befor()、after();

06.动画插值器TimeInterpolator，计算时间流逝的百分比；类型估值器TypeEvaluaor,计算当前的属性值
1）LinearInterPolator：匀速
2）AccelerateInterpolator：匀加速
3）AccelerateDecelerateInterpolator：起始加速，末尾减速
4）CycleInterpolator：循环播放，正弦曲线
5）DecelerateInterpolator：匀减速

07.ShapeDrawable -> shape；属性有：
1）corners：圆角，缩写 c
2）gradient：渐变色，缩写 g
3）padding：内边距，缩写 p
4）size：基本没用，缩写 s
5）solid：内部填充色，缩写 so
6）stroke：边框，以及虚边，缩写 st

08.StateListDrawable -> selector 属性值有：
1）state_pressed：按下的状态
2）state_selected：选中状态
3）state_enabled：可用状态
4）state_focused：得到焦点状态
5）state_checked：控件是否选中
6）state_checkable：控件可否使用

7）state_active：激活状态
8）state_first：开始状态
9）state_last：结束状态
10）state_middle：中间状态
11）state_window_focused：窗口已得到焦点状态

09.其他drawable
LayerDrawable -> layer-list
ClipDrawable -> clip
AnimationDrawable -> set
BitmapDrawable -> bitmap
LevelListDrawable -> level-list
TransitionDrawable  -> transition；继承自layer
insertDrawable -> inset

10.Bitmap，缓存机制LruCache与DiskLruCache，BitmapFactory.Options
1）inSampleSize，整数，最小为1，等比缩小原图宽高。
2）inJustDecodeBounds，true时只解析宽高不加载到内存中。

11.SVG:VectorDrawable（vector静态效果）、AnimatedVectorDrawable（animated-vector）：animated-vector组合objectAnimator与vector形成动态的动画效果


第十章 Android 日常总结
01.Android的系统架构
1）操作系统层OS：linux内核。
2）硬件抽象层：HAL（Hardware Abstraction Layer），内核与硬件电路之间的抽象接口层。
3）native C/C++ Libraries和Android运行环境RunTime。
4）应用程序框架Application Framework。
5）应用程序Application。

02.小常识
1）File所在路径的文件夹（Floder）存在时，写入数据时自动创建File；
Folder不存在，则需调用mkdir()；
当Folder的父类文件夹也不存在时，应调用mkdirs(),创建父类文件夹。
总结：为保险起见，需检查。
2）从XML中获取的有换行的字符串，会有空格，应先去除空格再使用。
3）viewGroup的LayoutParams是所有params的父类。
4）ViewDragHelper滑动控制类，子类有DrawerLayout与SlidingPaneLayout。
5）dalvik是运行时编译，ART是安装时就进行编译。目前采用的是ART模式。
6）multidex参见错误统计表.xlsx。
7）空白行，或者有注释的的行，Java编译器都会忽略掉
8）Android Q（系统10）中对于文件读写做了新的限制，无法直接获取除自身缓存外的其他文件，如需要之前的逻辑权限，需要在manifest中设置
android:requestLegacyExternalStorage="true"

另外，还可以通过 storageManager 来操作。

03.事件监听的几种形式
1）匿名内部类，推荐的主要用法。
2）内、外部实现类形式.
3）自身实现点击事件的接口.
4）xml中的onclick属性。

04.Intent：分显式与隐式两种：
显式为指定了component属性，明确启动哪个组件；
隐式是搜索符合条件的组件，供用户选择。
1）构造函数：可以是类名、action、Component（setClass）。
2）明确启动组件component（setComponent()）：明确需要启动组件，与xml中对应。
3）操作类型action（setAction()）：Java代码中只能存在一个，存在则必须有一个相同；xml中可存在多个。
4）类别筛选category（addCategory()）：Java代码中存在几个匹配几个，xml中可存在多个。
5）数据类型data与type：setDataAndType()，地址有特定规则，要么同时设置，要么单独只设置一个。
6）启动模式LaunchMode四种（manifest中用）：
standard（标准），
singleTop（栈顶复用），
singleTask（类似于单例，独一份，再次进入后清空在其之上的实例），
singleInstance（每次启动都是独立栈中的独一份）
7）标志也即启动模式（Intent中用）：
FLAG_ACTIVITY_NEW_TASK(需要搭配FLAG_ACTIVITY_CLEAR_TASK使用)；
FLAG_ACTIVITY_SINGLE_TOP,FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS(跳转页面后自动finish）；
android:excludeFromRecents="true"，目前未起作用)。
8）数据传递bundle：Intent内部已经封装好，不用自己封了，serializable，parcelable，也可以转成json字符串传过去。
9）也可以定义一个静态类，每次跳转页面前添加数据到静态类，跳转完成后从静态类中取出，同时移除。

05.handler执行
1）handler中执行enqueueMessage()方法将消息放入队列中，等待loop循环并找到此消息。
2）Looper.loop()方法是死循环，其中选取消息的方法Message msg = queue.next();也是一个死循环，没有消息时，其中的nativePollOnce()方法会阻塞主线程，释放CPU资源，进入休眠状态，直到取到消息或者发生事件，开始往下执行；
3）取到消息后开始执行handler的分发方法dispatchMessage()开始回调，方法执行完成后，此次消息处理完成。
4）handler分发dispatchMessage()：先检测message中的callback是否为空，不为空消费此消息；为空则检测handler自己的callback，return true则消费此消息，终止传递；为false则执行handler自带的handleMessage()。
5）异步线程中创建，需要先调用Looper.prepare().

public void run(){
    Looper.prepare();
    Handler handler = new Handler();
    Looper.loop().
}

06.Android性能优化
1）布局优化：include，merge，ViewStub，减少层级嵌套，加强view复用。
2）绘制优化：在onDraw中不要创建新对象，不执行耗时任务，view的绘制帧率保证60fps（一秒切换60帧画面，据说flutter可以达到120帧）是最佳的，每帧所需时间不超过16ms（16ms=1000/60）.
3）内存泄漏：分析工具MAT。
4）属性动画导致的内存泄漏：无限循环需要关闭。
5）响应速度优化和ANR日志分析：避免在主线程中做耗时操作，日志所在：/data/anr/traces.txt
6）Recycler与bitmap优化
7）线程优化：灵活应用线程池，避免创建大量线程。
8）避免创建过多对象；
9）灵活并酌情使用枚举类型；
10）常量使用static final来修饰。
11）使用android特有的数据结构，比如SparseArray和Pair等；
12）适当使用软引用与弱引用；
13）采用内存加磁盘缓存；
14）尽量使用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄漏。

07.Java内存优化
1）释放连接，io操作之类的连接。
2）释放对象，尽量使用局部变量，因为大多局部变量的生命周期随方法的结束而结束。
3）不要再循环里创建对象
4）基本类型代替对象类型。
5）字符串的多次修改，使用StringBuffer（线程安全的，synchroinzed 修饰）和StringBuilder（非线程安全，所以论速度，比buffer快）拼接。
6）单线程尽量使用 HashMap 和 ArrayList
7）提前分配StringBuffer，数组，array，vertor等的容量
8）合适的场所使用单例
9）尽量不要随意使用静态变量

08.获取当前方法的名称的两种方法。推荐第一种
1）StackTraceElement[] traceElement = Thread.currentThread().getStackTrace();
此方法取得的StackTraceElement栈：
第 0 条数据是VmStack的getThreadStackTrace；
第 1 条数据是Thread的getStackTrace
第 2 条数据是当前方法的所在位置。

2）StackTraceElement stack = new Throwable().getStackTrace();
此方法取得的StackTraceElement栈，它的第零条数据就是当前方法所在的位置。
StackTraceElement的属性
String declaringClass; 类的全名；getMethodName
String methodName; 对应的方法名；getClassName
String fileName; 类名；getFileName
int    lineNumber; 对应代码的行数；getLineNumber

09.TextView
letterSpacing="0.1"：字间距，按字的宽度的比例来算，默认为0；-1的话就只在第一个位置上显示了。
lineSpacingMultiplier="1.5"：行间距，按行的高度的比例算，默认为1；0-1之间的，行间距为负数，每行文字会重叠，为0是，所有的文字都会显示在一行。
lineSpacingExtra="@dimen/wh_20"：行间距，按dp来算
textIsSelectable="true"：是否可选择文字，默认为false

10.Fragment 的生命周期 12个
01）onAttach()
02）onCreate
03）onCreateView
04）onViewCreate
05）onActivityCreated
06）onStart
07）onResume
08）onPause
09）onStop
10）onDestoryView
11）onDestory
12）onDetach

11.Fragment 的添加过程
1）add 添加新的Fragment，需要与 hide 和 show 配合使用。推荐使用
FragmentManager manager=getSupportFragmentManager()；获取fragment的管理器
Fragment fragment=manager.findFragmentByTag(tag);//获取已存在Fragment
FragmentTransaction tran=manager.beginTransaction();//获取Fragment加载器
if(fragment==null){
    fragment = new XXXFragment();
    tran.add(fragment,tag);
}else{
    tran.show(fragment);
}
tran.commit();
tran.commitAllowingStateLoss();在activity被回收后，防止异常的提交。
2）addToBackStack 入栈；popBackStack 出栈。
3）replace 替换之前的Fragment。
4）remove

12.Fragment 搭配 ViewPager
1）FragmentPagerAdapter 一般用于适配较少页面，默认缓存上下两个页面，之后的fragment会回收view，也就是会执行onDestoryView方法，之后再次加载时会直接调用onCreateView方法。
2）FragmentStatePagerAdapter 适配较多页面，默认缓存上下两个页面，其他页面会被回收掉，是执行onDetach方法彻底移除，回收内存。
3）viewPager.offscreenPageLimit = 2 //会缓存两个页面，也就是显示一个，缓存两个，共三个，生命周期都不会改变。最优先。

13.SharedPreference 的 apply 与 commit 方法的区别。
SharedPreference 相关修改使用 apply 方法进行提交会先写入内存，然后异步写入磁盘，commit
方法是直接写入磁盘。如果频繁操作的话 apply 的性能会优于 commit，apply会将最后修改内容写入磁盘。
但是如果希望立刻获取存储操作的结果，并据此做相应的其他操作，应当使用 commit。

14.debug包安装失败的问题。
原因是：反编译当前apk发现的确清单文件中的确新加了这个属性，研究发现原来是Android Studio 3.0会在debug apk的manifest文件application标签里自动添加 android:testOnly="true"属性，导致IDE中run跑出的apk在大部分手机上只能用adb install -t 来安装。
1）解决方法一
在项目中的gradle.properties全局配置中设置：
android.injected.testOnly = false
2）解决方法二，加 -t ：　　
adb install -t app-debug.apk

15.window与WindowManager是ipc机制的应用：
1）addView(v,layoutparam)；
2）updateViewLayout(v,layoutparam)；
3）rempveView(v)；

16.系统自带的各种管理器与多媒体处理：
1）TelephonyManager：电话管理器；
2）SmsManager：短信管理器；
3）AudioManager：音频管理器；
4）Vibrator：振动器；
5）AlarmManager：手机闹钟服务；

6）MediaPlayer：音频；
7）SoundPool：音频；
8）VideoView：播放视频；
9）mediaRecorder：录制音频；


第十一章 混淆 ProGuard，参见app下的proguard文件，App研发录
01.混淆的过程
1）压缩Shrink：侦测并移除代码中的无用类，字段，方法和特性。
2）优化Optimize：对字节码进行优化，移除无用的指令。
3）混淆Obfuscate：使用a、b、c、d这样简短而无意义的名称，对类、字段和方法进行重命名。
4）预检Preveirfy：在java平台上对处理后的代码进行预检。

02.混淆的关键字
keep：保留类或类中的成员，防止它们被混淆或移除。
keepnames：保留类或类中的成员，防止它们被混淆，但当成员没有被引用时会被移除。
keepclassmembers：只保留类中的成员，防止它们被混淆或移除。
keepclassmembersnames：只保留类中的成员，防止它们被混淆，但当成员没有被引用时会被移除。
keepclasseswithmembers：保留类和类中的成员，防止它们被混淆和移除，前提是致命的类中的成员必须存在，如果不存在则还是会混淆。

keepattributes：保留自定义类的自定义属性
keepclassmembernames
keepclasseswithmembers
keepclasseswithmembernames

keepdirectories
keepnames
keeppackagenames
keepparameternames

feild：匹配类中的所有字段。
method：匹配类中的所有方法。
init：匹配类中的所有构造函数。
*：匹配任意长度的字符，但不含包名分隔符（.）。


第十二章 MVVM、MVC、MVP
01.MVC：
M（Model）：数据处理（网络，DB）
V（View）：xml、view
C（Controller）：activity，fragment

VC层耦合性高，基本可以理解为一层，直接与Model层进行交互。有个优化方案是把C层中的逻辑拆分出来，不过这与MVP也就没什么差别了。
适合于简单的以后也不会有什么变动的页面。

02.MVP
M（Model）：数据处理（网络，DB）
V（View）：xml、view，activity，fragment
P（Presenter）：业务逻辑层，相当于把MVC中C层的业务单独剥离出来

M <-> P <-> V
业务逻辑复杂的App，P层会过于臃肿，接口过多。

03.MVVM：可以理解成加入DataBinding的MVP
M（Model）：数据处理（网络，DB）
V（View）：xml、view，activity，fragment
VM（ViewModel）：业务逻辑层，

M <-> VM <-> V

减少了接口数量，不用再findViewById，实现了数据与视图的双向绑定，极大地简化代码。
单向绑定（@{}）与双向绑定（@={}），可以动态更新数据。

BaseObservor
@Bindable
notifyPropertyChanged(BR.xxx)

DataBinding实现MVVM数据绑定的工具
liveData解决MVVM的数据通信问题，可以感知组件的生命周期。

04.MVC与MVP的区别
1）功能复杂的话，MVC的activity或fragment会很庞大，view与model耦合严重
2）功能复杂的话，MVP会产生很多接口，activity需要很多接口方法来更新UI，model与view不直接进行交互，达到解耦的效果


第十三章 网络请求
01.HTTP 请求种类类
http://www.baidu.com/...
协议  主机地址     资源
1）GET      请求获取Request-URI所标识的资源
2）POST     在Request-URI所标识的资源后附加新的资源
3）HEAD     请求获取由Request-URI所标识的资源得响应消息报头
4）PUT      请求服务器存储一个资源，并用Request-URI作为其标识
5）DELETE   请求服务器删除Request-URI所标识的资源
6）TRACE    请求服务器回送收到的请求信息，主要用于测试或诊断
7）CONNECT  保留将来使用
8）OPTIONS  请求查询服务器的性能，或者查询与资源相关的选项

02.错误码含义：
400 bad Request    客户端请求有语法错误，不能被服务器所理解
401 unauthorized   请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用
403 forbidden      服务器收到请求，但是拒绝提供服务
404 not found      请求资源不存在，eg：输入了错误的URL
500 internal server error 服务器发生不可预期的错误
503 server unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复

03.TCP的三次握手与四次挥手
1）开始连接：客户端请求server连接，server发送响应码，客户端告诉server已匹配。
2）开始传输数据。
3）客户端告诉server请求断开连接，server发送两次回执，客户端与server断开

04.简述TCP、UDP、Socket
1）TCP是经过3次握手，4次挥手完成遗传数据的传递。
2）UDP是无连接的，知道IP地址和端口号，向其发送数据即可，不管数据是否发送成功。
3）Socket是一种不同计算机实时连接，比如说传送文件，即时通讯。


第十四章 IPC机制，AIDL
01.IPC机制：多进程间通信（待深入研究）
会造成的问题：
1）静态成员和单例模式完全失效：不同进程间的静态和单例是互相独立的。
2）线程同步机制完全失效：不同进程间的线程也是互相独立的。
3）SharedPreferences可靠性下降：不支持两个进程同时读写，有一定几率会丢数据。
4）application多次创建：新进程代表新的虚拟机的启动。
通信方式：序列化serializable与parcelable，Binder，Intent，共享文件，Messenger（待深入研究AIDL），ContentProvider，socket网络通信。

02.Binder（待深入研究）
实现IBinder接口（aidl快速实现Binder的工具），主要用在Service开发中，AIDL在PairServiceA中有应用。

03.IPC的几种通信方式
共享内存、消息传递、管道、信号量


第十五章 NDK 编程
01.JNI和NDK编程，JNI是java的本地交互，NDK是Android提供得工具集合，可以在android中更加方便的通过JNI来访问本地代码，如C，C++，NDK
还提供了交叉编译器，开发人员只需要简单的修改mk文件就可以生成特定的CPU平带的动态库，使用NDK有如下好处：
1）提高代码的安全性，so库反编译比较困难；
2）可以使用目前已有的C/C++开源库；
3）便于平台间的移植；
4）提高程序在某些特定情形下的执行效率，但是并不能明显提升Android程序的性能；
5）在cmd终端中进入到main目录下 cd (具体路径)/apiutils/src/main
执行此语句  javah -d jni -classpath ../../build/intermediates/classes/debug com.sky.NDKString  会自动生成jni文件com_sky_NDKString.h,自定义.c的file


第十六章 AsyncTask 已废弃
01.AsyncTask 主要方法：
1）onPreExecute()  准备工作，如显示进度条可以在此初始化。
2）doInBackground(params)  异步任务，只有此方法是执行在子线程中，在onPreExecute之后立即执行。
3）onProgressUpdate(values)  可在此设置进度条的更新，需要在doInBackground()中调用publishProgress()方法
4）onPostExecute(result)  异步任务完成后返回的结果。

02.AsyncTask的实现原理：参考版本10.0系统
AsyncTask是创建一个FutureTask(Callable)的任务，通过execute方法把任务加入到任务池，之后再转到线程池中。
内部的任务池和线程池可以说都是饿汉模式的单例，类加载的时候就已经确定了。

10.0系统下AsyncTask的实现过程：
第一步：创建AsyncTask，并把任务加入任务池中；
new AsyncTask()时，新建了一个Callable，一个FutureTask，在调用execute(params)时，会把状态设为Running，执行执行onPreExecute()方法，设置Callable的参数，把FutureTask放入任务池中。
具体代码如下：
mStatus = Status.RUNNING;//变为运行状态，之前有状态检查，如果已经运行了，会抛出异常，所以execute只能调用一次。
onPreExecute();//执行准备方法
mWorker.mParams = params;//为Callable设置参数。
exec.execute(mFuture);//把FutureTask加入任务池中，开始执行。

第二步：放入任务池后，开始轮循取出任务，交给线程池，开始执行；
private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;
此成员变量是个任务池，内部有一个双端队列ArrayQueue（最大16个元素）；
在execute()方法中通过offer将任务加入队列尾部中，紧接着调用scheduleNext()方法，通过poll取出队首任务加入线程池执行。

第三步：线程池中的线程开始调用Runnable任务，执行Callable的call方法
然后开始执行Callable中的call方法，其中会调用doInBackground(params)方法。
完成后返回的结果，会在在FutureTask中的done方法中调用get获取，通过postResultIfNotInvoked(result)方法传递给Handler；
在handlermessage方法中调用AsyncTask的finish()方法返回result，其中会调用onPostExecute(result)方法。会在这个方法中检查是否已取消。

public static final Executor THREAD_POOL_EXECUTOR;
此成员变量就是线程池，10.0系统下，此线程池内的队列使用的是SynchronousQueue，一个只有一个元素的阻塞队列，
一个核心线程，20的最大线程数，一个元素的阻塞队列，加一个初始容量为16的ArrayQueue（任务池），没有上限；没有上限，那要饱和策略啥用，还真能突破int的最大值？，之后再添加会执行饱和策略。

10.0系统下的饱和策略是再创建一个线程池，来容纳多出来的任务，此线程池采用了链表LinkedBlockingQueue，默认上限，默认开启5个核心线程，最大也只开5个，因为开启了超时机制，所以这五个核心线程之后是会被回收的。

03.AsyncTask的优缺点
优点：AsyncTask是一个轻量级的异步任务处理类，使用方便，代码简洁，整个异步任务可以通过cancel()进行控制。
缺点：不适用于处理长时间的异步任务，一般这个任务过程最好控制在几秒以内，如果长时间的异步任务就需要考虑多线程的控制问题，当处理多个异步任务时，UI更新变得复杂。

04.Handler的优缺点
优点：代码结构清晰，容易处理多个异步任务。
缺点：消息的优先级当有多个异步任务时，由于要配合 Thread 或 Runnable，代码可能会稍显冗余。

总结：AsyncTask不失为一个非常好用的异步任务处理类，只要不是频繁大量对UI进行更新，可以考虑使用。
而Handler在处理大量UI更新时可以考虑使用。
